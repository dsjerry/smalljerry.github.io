{"meta":{"title":"Hexo","subtitle":"","description":"","author":"smalljerry","url":"https://gitee.com/dsjerry/smalljerry","root":"/smalljerry/"},"pages":[],"posts":[{"title":"test","slug":"test","date":"2020-08-10T01:15:21.000Z","updated":"2020-08-10T12:56:12.909Z","comments":true,"path":"2020/08/10/test/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/08/10/test/","excerpt":"","text":"","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Vue Router知识小补充","slug":"Vue-Router小拓展","date":"2020-08-05T01:17:50.000Z","updated":"2020-08-10T14:25:50.546Z","comments":true,"path":"2020/08/05/Vue-Router小拓展/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/08/05/Vue-Router%E5%B0%8F%E6%8B%93%E5%B1%95/","excerpt":"前提小知识点： 前提：在这里做些小笔记，一边看笔记一边看官方文档，方便理解 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由 嵌套路由要嵌套的内容也是写进模板组件里面的，而不是写进本身的HTML里面。然后需要在 VueRouter 的参数中使用 children 路由组件传参，就是使用 props 来代替 $route.xx.xx，提高灵活度","text":"前提小知识点： 前提：在这里做些小笔记，一边看笔记一边看官方文档，方便理解 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由 嵌套路由要嵌套的内容也是写进模板组件里面的，而不是写进本身的HTML里面。然后需要在 VueRouter 的参数中使用 children 路由组件传参，就是使用 props 来代替 $route.xx.xx，提高灵活度 基础标签router-link1&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link&gt; 组件支持用户在具有路由功能的应用中 (点击) 导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 &lt;a&gt; 标签，可以通过配置 tag 属性生成别的标签.。 当点击&lt;router-link&gt; 的时候，其实可以说等同于调用了router.push(...)，这个东西就是编程式的导航，router-link 是声明式 当 &lt;router-link&gt; 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active。 这个 class 也可以自定义，通过路由的构造选项 linkActiveClass 来全局配置： 1234var router = new VueRouter(&#123; routes, linkActiveClass: &#x27;active&#x27;,&#125;); 然后在style配置class样式就行 router-view&lt;router-view&gt; 是一个 functional 组件，渲染路径匹配到的视图组件，它里面可以内嵌自己的 &lt;router-view&gt; 可以添加动态效果，使用 &lt;transition&gt; 组件： 123&lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; out-in ：当前元素先进行过渡，完成之后新元素过渡进入。 in-out ：新元素先进行过渡，完成之后当前元素过渡离开。 使用的时候要设置相对应的 css 样式，例如： 123456789.v-enter,.v-leave-to &#123; opacity: 0; transform: translateX(150px);&#125;.v-enter-active,.v-leave-active &#123; transition: all 1s ease;&#125; 路由对象一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的**路由记录 (route records)**。 例如：对于 $route.params： 模式 匹配路径 $route.params /user/:username /user/evan &#123; username: &#39;evan&#39; &#125; /user/:username/post/:post_id /user/evan/post/123 &#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125; 路由对象属性 $route.path 类型: string 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 $route.params 类型: Object 一个 key/value 对象，包含了动态片段和全匹配片段，例如，对于路径 /login/13，则有 $route.params.id == 13，如果没有路由参数，就是一个空对象。 $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 …… APIvm.$mount() 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。 返回值是 vm 实例自身 123const app = new Vue(&#123; router&#125;).$mount(&#x27;#app&#x27;)","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vue/"}]},{"title":"php数组的常用函数","slug":"php数组的常用函数","date":"2020-07-28T01:58:18.000Z","updated":"2020-07-28T07:11:25.685Z","comments":true,"path":"2020/07/28/php数组的常用函数/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/28/php%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"指针操作函数数组指针用于指向数组中某个元素，默认情况下指向数组的第1个元素。通过移动或指针的位置，可以访问数组中的任意元素 函数名称 功能描述 current() 获取数组中当前指针指向的元素的值 key() 获取数组中当前指针指向的元素的值 next() 将数组中的内部指针向前移动一位 prev() 将数组中的内部指针倒回一位 each() 获取数组中当前的键值对并将数组指针向前移动一步 end() 将数组的内部指针指向最后一个元素 reset() 将数组的内部指针指向第一个元素 数组元素操作函数 函数名称 功能描述 aray_pop() 将数组最后一个元素弹出（出栈） array_push() 将一个或多个元素压入数组的末尾（入栈） array_unshift() 在数组开头插入一个或多个元素 array_shift() 将数组开头的元素移出数组 array_unique() 移除数组中重复的值 array_slice() 从数组中截取部分数组 array_splice 将数组中的一部分元素去掉并用其他值取代 排序数组 函数名称 功能描述 sort() 对数组排序（从低到高） rsort() 对数组逆向排序（从高到低） asort() 对数组进行排序并保持键值关系 ksort() 对数组按照键名排序 arsort() 对数组进行逆向排序并保持键值关系 krsort() 对数组按照键名逆向排序 shuffle() 将数组元素顺序打乱 array_multisort() 对多个数组或多维数组进行平排序 检索函数 函数名称 功能描述 in_array() 检查数组中是否存在某个值 array_search() 在数组中搜索给定的值，如果成功则返回相应的键名 array_key_exists() 检查给定的键名是否存在于数组 其他数组函数 函数名称 功能描述 count() 计算数组中的元素数目或对象中的属性个数 range() 建立一个包含指定范围元素的数值 array_rand() 从数组中随机取出一个或多个元素 array_keys() 获取数组中部分或所有的键名 array_values() 获取数组中所有的值 array_column() 获取数组中指定的一列 array_sum() 计算数组中所有值得和 array_reverse() 返回一个元素顺序相反的数组 array_merge() 合并一个或多个数组 array_flip() 交换数组中的键和值 array_combine() 创建数组，用一个数组的值作为其键名，另一个数组的值作为其值 array_chunk() 将一个数组分割为多个 array_fill() 用给定的值填充数组 array_replace() 使用传递的数组替换第一个数组的元素 array_map() 为数组中的每个元素应用回调函数 array_walk() 使用自定义函数对数组的每个元素做回调处理","categories":[{"name":"课堂学习","slug":"课堂学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php","slug":"php","permalink":"https://gitee.com/dsjerry/smalljerry/tags/php/"}]},{"title":"php开发环境搭建","slug":"php开发环境搭建","date":"2020-07-24T07:28:40.000Z","updated":"2020-07-24T14:20:00.418Z","comments":true,"path":"2020/07/24/php开发环境搭建/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/24/php%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"在Windows平台上搭建~(^▽^) 其实在下载的文件中怎么配置上面都有说明，只是全是鸡肠看起来蛋疼 文章底部有一些补充的小知识和相关知识点的解释（￣︶￣）↗","text":"在Windows平台上搭建~(^▽^) 其实在下载的文件中怎么配置上面都有说明，只是全是鸡肠看起来蛋疼 文章底部有一些补充的小知识和相关知识点的解释（￣︶￣）↗ 安装 ApacheApache下载地址 配置Apache解压下载的压缩包，打开Apache的配置文件conf/httpd.conf 找到配置项Define SRVROOT，将里面的路径更改为自己下载的 apache 的根目录 路径要使用 / 而不是 \\ 找到 ServerName，去掉前面的#，这里配置自己的域名，如果没有域名，就写个IP地址上去。 例如：ServerName 127.0.0.1:80，也可以写成 localhost:80 安装 Apache以管理员的身份打开命令提示符，切换到 Apache目录下的 bin 目录，执行命令： 安装： 1httpd.exe -k install 提示：这里安装之前Apache文件夹的名字叫什么，安装后Apache服务的名字就叫什么 卸载： 1httpd.exe -k uninstall 启动Apache服务有三种启动方式，通过命令行、通过Apache软件和通过系统服务 通过命令行启动 Apache1234# 启动服务net start Apache# 停止服务net stop Apache 通过软件启动 Apache打开apache目录下的bin目录，双击 ApacheMonitor.exe 启动 通过系统服务启动Apache任务管理 &gt; 服务 &gt; 打开服务 &gt; 启动apache 访问测试浏览器输入：localhost，如果看到 It works！ 那就成功了。Apache默认打开的是 htdoc目录下的 index.html 安装PHPPHP 7.4 下载地址，找到 Thread Safe 版本，下载 zip 压缩包 创建配置文件解压之后，找到 php.ini-development 文件，复制粘贴一份，然后改名为 php.ini 在Apache中引入PHP模块 打开Apache的配置文件 httpd.conf，引入 PHP 为 Apache 提供的DLL 模块 123456LoadModule php7_module &quot;php在电脑中的路径&#x2F;php7apache2_4.dll&quot;&lt;FilesMatch &quot;\\.php$&gt; setHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt;PHPIniDir &quot;php在电脑中的路径&#x2F;php-7.4.7&quot;LoadFile &quot;php在电脑中的路径&#x2F;libssh2.dll&quot; 配置 Apache 的索引页 访问 localhost 的时候，实际上是在访问 localhost/index.html。在配置文件中搜索 DirectoryIndex 起初的模样 123&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;&#x2F;IfModule&gt; 加上另外的 index.php 123&lt;IfModule dir_module&gt; DirectoryIndex index.php index.html&lt;&#x2F;IfModule&gt; 访问测试修改了 Apache 配置文件后，要重新启动一下。 在 Apache 的 htdoc 目录下创建一个 test.php，编辑内容： 123&lt;?php phpinfo();?&gt; 通过访问 localhost/test.php测试是都安装成功 打开常用扩展打开 php.ini，搜索 extension_dir，增加一行 extension_dir = &quot;php安装的目录/ext&quot; 一般会启用的功能： 123456extension=curlextension=gd2extension=mbstringextension=mysqliextension=opensslextension=pdo_mysql web服务器配置在每次修改配置文件之后都要重启 Apache 才会生效。如果想恢复默认，在conf/original目录中获取 配置虚拟主机其实在真正使用的时候，在购买域名平台上的控制台中就可以增加和修改 dns 的映射关系。 在学习过程中使用Windows系统配置，可以更改系统的 hosts 文件，这个文件用于配置域名和IP地址之间的解析关系 配置域名用管理员打开 C:/Windows/System32/drivers/etc 目录下的 hosts 文件，配置域名和IP地址的映射关系 12127.0.0.1 php.test127.0.0.1 www.php.test 启用辅配置文件辅配置文件是 Apache 配置文件 httpd.conf 的扩展文件，默认是不启动的，去掉 # 将它启动 1Include conf&#x2F;extra&#x2F;httpd-vhost.conf 配置虚拟主机打开 httpd-vhost.conf文件 将下面这一块注释掉，作为参考 12345678#&lt;VirtualHost *:80&gt;# ServerAdmin webmaster@dummy-host.example.com# DocumentRoot &quot;$&#123;SRVROOT&#125;&#x2F;docs&#x2F;dummy-host.example.com&quot;# ServerName dummy-host.example.com# ServerAlias www.dummy-host.example.com# ErrorLog &quot;logs&#x2F;dummy-host.example.com-error.log&quot;# CustomLog &quot;logs&#x2F;dummy-host.example.com-access.log&quot; common#&lt;&#x2F;VirtualHost&gt; 新增虚拟主机 1234567891011# 第一个虚拟主机&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:&#x2F;web&#x2F;apache&#x2F;htdocs&quot; ServerName localhost&lt;&#x2F;VirtualHost&gt;# 第二个虚拟主机&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:&#x2F;web&#x2F;www&#x2F;thinkphp&#x2F;public&quot; ServerName thinkphp.test ServerAlias www.thinkphp.test&lt;&#x2F;VirtualHost&gt; ServerAlias 取别名，不管访问哪个，都是指向同一网站 这时已经是可以访问配置好的页面了，访问 localhost 或者 thinkphp.test 测试配置 下面的是一些自定义的功能 [](￣▽￣)* ，✿✿ヽ(°▽°)ノ✿，ヾ(◍°∇°◍)ﾉﾞ，(^▽^)，(^o^)/，Thanks♪(･ω･)ﾉ，٩(๑&gt;◡&lt;๑)۶，O(∩_∩)O哈哈 访问权限控制控制服务器中哪些文件允许被外部访问，在 httpd.conf 中，默认站点目录 htdocs 已经配置为允许外部访问，其他目录要手动配置。以 www.admin.test 为例 在 httpd-vhost.conf 文件中： 123456789&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:&#x2F;web&#x2F;www.admin.test&quot; ServerName admin.test&#96;&lt;&#x2F;VirtualHost&gt;&lt;Directory &quot;D:&#x2F;web&#x2F;www.admin.test&quot;&gt; Require local #Require all granted（充许局域网内其他电脑访问） #Require all denied（不充许局域网内其他电脑访问）&lt;&#x2F;Directory&gt; Require local：只允许本地访问 Require all granted：允许所有访问 Require all denied：拒绝所有访问 分布式配置文件为目录单独进行配置的文件，可以实现在不中期服务器的前提下更改某个目录的配置，编辑 httpd-vhost.conf 文件 1234&lt;Directory &quot;D:&#x2F;web&#x2F;www.admin.test&quot;&gt; Require local AllowOverride All&lt;&#x2F;Directory&gt; 添加 AllowOverride All 后， Apache 回到站点下各个目录中读取名称为 “ .htaccess ” 的分布式配置文件，该文件中的配置将会覆盖原有的配置 这可能会影响服务器运行效率，如果想关掉，改为 AllowOverride None 目录浏览功能在目录“D:/web/w ww.admin.test”中创建文件 .htaccess，编写配置： 123Options Indexes# 不想使用的话Options -Indexes 自定义错误页面在遇到错误的时候，Apache会使用 error 目录中的模板显示一个页面，通过 ErrorDocument 指令对不同的状态码进行配置 在 或 .htaccess 中，加入： 123ErrorDocument 403&#x2F;403.htmlErrorDocument 404&#x2F;404.htmlErrorDocument 500&#x2F;500.html ✿✿ヽ(°▽°)ノ✿ 如果深入配置的话，后面还可以配置 mysql 和 thinkPHP 了解一下了解周边小知识，提高学习兴趣~奥利给！！！ 关于Apache因为 Apache HTTP Server Project 它本身不提供发行的软件下载，提供下载的比如有：ApacheHaus，Apache Lounge等等。这里使用的服务器软件简称是 httpd，是其中的一项产品，在浏览器搜索的时候搜索apache httpd就可以找到下载的地方了。Apache 旗下还有别的产品，比如和 Java 比较般配的 Tomcat，也是 Apache 旗下的。 配置项 在上面配置Apache引入PHP文件的时候，LoadModule 是加载模块的指令，加载了 php7_module 模块，下面的代码时对PHP文件的解析，利用正则表达式匹配 “ .php “ 文件，然后通过 setHandler 提交给PHP处理。PHPIniDir 用于指定 php.ini 文件保存的目录 在上面的设置默认入口文件的时候，首先检测是否存在 inidex.php，然后再检测 index.html 配置虚拟主机相关知识虚拟主机是 Apache 提供的一个功能，通过虚拟主机可以在一台服务器上部署多个网站，而不同的域名可以解析到同一个IP地址上。 因此，当用户通过不同的域名访问同一台服务器时，虚拟主机功能就可以让用户访问到不同的网站。 会遇到的问题端口占用Apache 默认监听 80 端口，如果端口被占用，Apache将无法启动。 在Windows中可以在命令提示符中使用net -ano 查看当前的端口情况 使用 tasklist | findstr &quot;PID&quot;可以查看当前占用端口的是什么应用程序 安装多个ApacheApache可以多个服务同时进行工作，前提是要服务名称和端口号不冲突。在Apache配置文件中，找到Listen，就可以修改监听的端口 安装多个Apache： 1httpd.exe -k install -n apache2 卸载 1httpd.exe -k uninstall -n apache2 关于PHP版本PHP除了版本的选择，还有一个选择就是 Thread Safe（线程安全）和 No Thread Safe（非线程安全） PHP和Apache搭配的时候，选择Thread Safe 配置php.ini-development：开发环境配置模板 php.ini-production：生产模式，适合上线的时候使用","categories":[{"name":"技巧学习","slug":"技巧学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php","slug":"php","permalink":"https://gitee.com/dsjerry/smalljerry/tags/php/"},{"name":"apache","slug":"apache","permalink":"https://gitee.com/dsjerry/smalljerry/tags/apache/"}]},{"title":"vscode配置phpcs","slug":"vscode配置phpcs","date":"2020-07-23T09:06:35.000Z","updated":"2020-08-10T12:57:32.620Z","comments":true,"path":"2020/07/23/vscode配置phpcs/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/23/vscode%E9%85%8D%E7%BD%AEphpcs/","excerpt":"1. 安装这里使用 composer 安装 全局安装1composer global require squizlabs&#x2F;php_codesniffer 局部安装1composer require --dev squizlabs&#x2F;php_codesniffer 局部安装是在项目的根目录","text":"1. 安装这里使用 composer 安装 全局安装1composer global require squizlabs&#x2F;php_codesniffer 局部安装1composer require --dev squizlabs&#x2F;php_codesniffer 局部安装是在项目的根目录 2. 安装vscode插件打开 Visual Studio Code 搜索 phpcs 进行安装。 安装成功后点击启用就行了，或者在配置文件中配置 1&quot;phpcs.enable&quot; : &quot;true&quot; 3. 配置参数在 setting.json 中配置参数，配置代码的验证标准 1&quot;phpcs.standard&quot;: &quot;PSR2&quot; 代码的标准有：MySource, PEAR, PHPCS, PSR1, PSR2, Squiz, Zend等 可以在自己 phpcs 的安装目录中看自己安装了哪些 phpcs 标准 使用 Composer 全局安装的话，phpcs 目录也是在 composer 目录下的 文件目录在xxx\\Composer\\vendor\\squizlabs\\php_codesniffer\\src\\Standards 这样基本配置就完成了 其他的配置标准： 没有 1&quot;phpcs.standard&quot;: null 使用默认的标准 1&quot;phpcs.standard&quot;: &quot;&quot; 设置默认标准，执行 1phpcs --config-set default_standard &lt;标准名&gt; 更多配置去官网看文档。pear 4. vscode 中其他的 PHP 配置配置PHP执行路径1&quot;php.validate.executablePath&quot;: &quot;xxx/php/php7.3.4nts/php.exe&quot;, 这里使用的是绝对路径","categories":[{"name":"技巧学习","slug":"技巧学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vscode,插件","slug":"vscode-插件","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vscode-%E6%8F%92%E4%BB%B6/"}]},{"title":"第1章_绪论","slug":"数据结构_第1章-绪论","date":"2020-07-23T02:55:52.000Z","updated":"2020-07-23T06:54:20.088Z","comments":true,"path":"2020/07/23/数据结构_第1章-绪论/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/","excerpt":"书本是在太厚，结合书本和老师的PPT整理一下知识点。希望哟用~ [](￣▽￣)~* 什么是数据结构随着计算机技术的发展，计算机应用范围更广，所处理的数据更复杂。如果要提高数据处理的效率，就必须研究数据本身的特性、数据元素之间的关系，以及如何有效地将数据组织存储在计算机内。 数据结构 和 数据库 有什么不同？数据结构指数据的组织方式，着重于数据之间的相互关系。数据库指一定规则存储在一起的数据集合，向外提供查询、插入、更新、删除等服务，着重于数据的存储与管理。数据结构通常与内存有关，数据库通常与硬盘有关。","text":"书本是在太厚，结合书本和老师的PPT整理一下知识点。希望哟用~ [](￣▽￣)~* 什么是数据结构随着计算机技术的发展，计算机应用范围更广，所处理的数据更复杂。如果要提高数据处理的效率，就必须研究数据本身的特性、数据元素之间的关系，以及如何有效地将数据组织存储在计算机内。 数据结构 和 数据库 有什么不同？数据结构指数据的组织方式，着重于数据之间的相互关系。数据库指一定规则存储在一起的数据集合，向外提供查询、插入、更新、删除等服务，着重于数据的存储与管理。数据结构通常与内存有关，数据库通常与硬盘有关。 数据结构的定义用计算机解决具体问题大致需要下列几个步骤： 首先从具体问题抽象出一个数学模型 然后设计一个解出数学模型的算法 最后编写程序、运行并调试，最终得到正确结果 寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述。但是有些问题用数学的语言很难表示，这就需要从数据入手分析问题。 数据结构是一门研究非数值计算程序设计问题中计算机操作对象（数据元素）一级它们之间的关系和操作等的学科 主要研究： 数据元素之间固有的逻辑关系——数据逻辑结构 数据元素及关系在计算机内的表现——数据存储结构 对数据结构的操作——算法（实现关系） 基本概念和术语目录 数据 数据元素 数据项 数据对象 数据结构 具体内容 数据：是描述客观事物的数和字符的集合（一个班全体学生数据记录的集合） 数据元素：数据的基本单位（班中每个学生记录都是一个数据元素）。数据元素有时也称为元素、结点、顶点或者记录… 数据项：具有独立含义的数据最小单位，也称字段或域（班中每个数据元素是由学号、姓名、年龄等 数据项 组成） 数据对象：性质相同的数据元素的集合，是一个数据的子集。数据结构课程中讨论的通常指的是数据对象 数据结构：所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定关系的数据元素的集合 可以理解为：数据结构 = 数据 ＋ 结构 特点：数据元素集合相同，而其上的关系不同，则构成的结构不同 数据结构通常包括以下几个方面： 数据的逻辑结构：由数据的逻辑关系构成 数据的存储结构：数据元素及其关系在计算机存储器中的存储表示，也称作数据的物理结构 数据的运算：施加在该数据上的操作 数据结构的形式定义数据结构是一个二元组 DS = (D,R)。D是数据元素的有限集，R是D上关系的有限集 关系的表示 序偶：有序对。例如：&lt;班主任，班长1&gt; 前驱：序偶中第一元素为第二元素的前驱 后继：序偶中第二元素为第一元素的后继 数据结构的三个方面12345678910111213graph LRA[数据结构的三个方面] --&gt;B[逻辑结构] B --&gt; E(线性结构) E --&gt; E1(线性表栈) E --&gt; E2(列队串) B --&gt; F(非线性结构) F --&gt; F1(树形结构) F --&gt; F2(图形结构) F --&gt; F3(集合结构)A[数据结构的三个方面] --&gt;C[存储结构] C --&gt; G(顺序结构) C --&gt; H(链式结构)A[数据结构的三个方面] --&gt;D[数据的运算: 检索, 排序, 插入, 删除, 修改等] 逻辑结构数据的逻辑结构是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中提炼出来的。 数据的逻辑结构与数据的存储无关，是独立于计算机的，可以看作是从问题中抽象出来的数学模型。数据结构中主要讨论数据运算之间的相邻关系和邻接关系","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"努力学习","slug":"努力学习","date":"2020-07-21T08:52:34.000Z","updated":"2020-07-23T06:34:45.670Z","comments":true,"path":"2020/07/21/努力学习/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/21/%E5%8A%AA%E5%8A%9B%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"随笔测试 :100:测试 :two:测 :four:试 :kissing:","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"会话技术","slug":"会话技术","date":"2020-07-21T03:32:09.000Z","updated":"2020-07-23T06:59:47.104Z","comments":true,"path":"2020/07/21/会话技术/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/21/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","excerpt":"概述：HTTP 协议是无状态的协议。当一个用户请求一个页面之后再请求另外一个页面时，HTTP 无法知道这两个请求时来自同一个用户。所以就需要会话技术来记录用户的状态 会话技术是维护同一个浏览器与服务器之间多次请求数据状态的技术。PHP中常用的会话技术有 Cookie 和 Session 两种， Cookie：在浏览器端存储数据并以此来跟踪和识别用户的机制 Session：将信息存放在服务器端的会话技术","text":"概述：HTTP 协议是无状态的协议。当一个用户请求一个页面之后再请求另外一个页面时，HTTP 无法知道这两个请求时来自同一个用户。所以就需要会话技术来记录用户的状态 会话技术是维护同一个浏览器与服务器之间多次请求数据状态的技术。PHP中常用的会话技术有 Cookie 和 Session 两种， Cookie：在浏览器端存储数据并以此来跟踪和识别用户的机制 Session：将信息存放在服务器端的会话技术 Cookie当用户通过浏览器访问 Web服务器 时，服务器会给用户发送一些信息，这些信息都保存在 Cookie 中。当浏览器再次服务器的时候，会在请求头中同时将 Cookie 发送给服务器。 利用 Cookie 可以跟踪用户与服务器之间的会话状态，通常应用于保存浏览历史、保存购物车商品和保存用户登录状态等场景。 当用户第一次访问服务器时，服务器会在响应消息中增加 Set-Cookie 头字段，将信息以 Cookie 的形式发送给浏览器，保存到浏览器缓冲区。下次访问的时候再将 Cookie 发给服务器，这样服务器就识别出了是哪个用户在发送请求。（关于 Cookie 的一些知识在文章底部） Cookie的一些缺点： 附加在 HTTP 消息中，增加了数据流量 在 HTTP 中是以明文传输的，安全性不高，容易被窃取 Cookie 存储于浏览器，可以被篡改，服务器接收后必须验证数据的合法性 浏览器限制 Cookie 的数量和大小（一般是50个，一个不超过4KB） Cookie的基本使用① 创建Cookie 在 PHP 中使用 setcookie() 函数可以创建和修改Cookie。其声明方式如下： 123456789bool setcookie( string $name, // Cookie 的名字（必选） string $value = &quot;&quot;, // Cookie 的值 int $expire = 0, // Cookie 的有效期 string $path = &quot;&quot;, // Cookie 在服务器端的路径 string $domain = &quot;&quot;, // Cookie 的有效域名 bool $secure = false, // 指定是否通过安全的 HTTPS 连接来传输 bool $httponly = false // 指定 Cookie 只能通过 HTTP 协议访问) 实现代码 1setcookie(&#x27;abc&#x27;, &#x27;123&#x27;, time() + 1800) ​ 第三个参数是时间戳，省略的时候，Cookie 会在浏览器结束的时候关掉 如果使用 JavaScript 操作 Cookie，setcookie() 的 $httponly 的值要设置为 false ② 获取Cookie 在PHP中，任何从客户端发送的 Cookie 数据都会被自动存入到 $_COOKIE 超全局数组( $_COOKIE[] )变量中，以此来获取 Cookie 数据 123456789setcookie(&#x27;name&#x27;, &#x27;张三&#x27;);echo $_COOKIE[&#x27;name&#x27;];// 保存和获取数组形式的Cookiesetcookie(&#x27;history[one]&#x27;, 1);setcookie(&#x27;history[two]&#x27;, 2);$history = isset($_COOKIE[&#x27;history&#x27;]) ? (array)$_COOKIE[&#x27;history&#x27;] : [];foreach ($history as $k =&gt; $v) &#123; echo &quot;$k - $v &lt;br&gt;&quot;&#125; 当 PHP 第一次使用 setcookie() 来创建 Cookie 时，$_COOKIE 中没有这个数据，当浏览器下次请求的时候才可以通过 $_COOKIE 获取到值 ③ 删除Cookie 如果没设置过期时间，当浏览器关闭的时候Cookie文件就会被清除。如果想自定义删除： 1setcookie(&#x27;data&#x27;, &#x27;&#x27;, time() - 1); 表示立即过时，相当于删除了。value 设置为空，过期时间设置为小于当前系统时间。 Cookie 的路径和域名Chrome 浏览器中，设置 &gt; 高级设置 &gt; 隐私设置 &gt; 内容设置 &gt; 所有Cookie和网站数据 不同版本的浏览器可能不同，不同浏览器能够存放的数量也可能不同 超全局变量 $_REQUEST默认情况下，$_REQUEST超全局变量数组变量，可以同时获取用户 GET 和 POST 请求方式提交的数据 1234&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;test.php?a&#x3D;xxx&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;b&quot; value&#x3D;&quot;yyy&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;&lt;&#x2F;form&gt; 在 test.php 中 1print_r($_REQUEST); $_REQUEST 的值受 php.ini 文件中的 request_order 影响 1request_order = &quot;GP&quot; G表示$_GET，P表示 $_POST 添加 C（$_COOKIE）可以接受 Cookie 数据，PHP解析的优先级是 C&gt;P&gt;G。接受数据同名的时候，优先级高的会覆盖优先级低的 PHP解析优先级也可以改，同样在 php.init 文件中，修改 1variable_order = &quot;PG&quot; 后解析的新值会覆盖旧值 SessionSession 在网络应用中称为会话，通常用于保存用户登录状态、保存生成的验证码等 Session 是一种服务器端的技术，它的生命周期从用户访问页面开始，知道断开与网站的连接结束。Web服务器在运行时会为每个用户的浏览器创建供其一个独享的 Session文件 每一个 Session 都具有一个唯一的会话ID，用于标识不同的用户。会话ID会分别保存在客户端和服务器端，客户端通过 Cookie 保存，而服务器端以文件的形式保存在 php.ini 指定的 Session目录（Windows默认保存：C:Windows\\Temp） Session的基本使用① 启动 使用 session_start() 启动，该函数返回值为布尔值，成功返回true，失败false 可在浏览器中 Network 中 点中某一条响应查看它的 Session ② 使用 可以通过 $_SESSION 添加、读取、修改Session中的数据 123456789session_start();$_SESSION[&#x27;username&#x27;] = &#x27;Tome&#x27;;$_SESSION[&#x27;id&#x27;] = [1, 2, 3];if (isset($_SESSION[&#x27;test&#x27;])) &#123; $test = $_SESSION[&#x27;test&#x27;];&#125;unset($_SESSION[&#x27;username&#x27;]); // 删除单个数据$_SESSION = []; // 删除所有数据session_destroy(); // 结束当前会话 $_SESSION = []，可以删除 Session 中的所有数据，但是 Session文件还是存在的，它是一个空文件 如果要删除这个空文件，使用session_destroy() ③ Session 的配置 配置项 含义 session.name 指定 Cookie 的名字，只能由字母、数字组成，默认为PHPSESSID session.save_path 读取或设置当前会话文件保存路径，默认为“C:Windows\\Temp” session.auto_start 指定是否在请求开始时自动启动一个会话，默认值是0（不启动） session.cookie_lifetime 以秒数指定发送到浏览器的 Cookie 的生命周期，默认为0（知道浏览器关闭） session.cookie_path 设定会话 Cookie 的路径，默认为 / session.cookie.domain 设定会话 Cookie 的域名，默认为没有 session.cookie_secure 是否仅通过安全连接发送 Cookie，默认 off session.cookie_httponly 是否仅通过HTTP访问 Cookie，默认 off PHP7.0 开始，在 session_start() 中可以对 Session进行配置，用于覆盖 php.ini 中对Session的配置指令 1session_start([&#x27;name&#x27; =&gt; &#x27;MySESSID&#x27;]); 在这里配置的时候，键名不需要加上 session. 在这里配置的时候，session.cookie_lifetime（整形），session.auto_start、session.cookie_secure 和 session.cookie_httponly 为布尔型，其它的是字符串型 session_start() 中的配置只在脚本运行周期中生效，并不影响 php.ini 中原本的配置 Session 机制Session 机制是通过调用 session_set_save_handler 实现的 默认情况下，PHP中的Session是通过实现 SessionHandlerInterface 接口，将其以文件的形式存储在服务器中的，这个接口有6种抽象方法： close：关闭 Session destroy：销毁 Session gc：垃圾回收 open：开启 Session read：读取 Session write：写入 Session 123456789interface SessionHandlerInterface&#123; public function close(); public function destroy(string $session_id); public function gc(int $maxlifetime); public function open(string $save_path, string $session_name); public function read(string $session_id); public function write(string $session_id, string $session_data);&#125; default charset=utf-8; 通过重新实现接口，完成具体的实现方法，然后再利用 Session机制可以改变 Session 存储的默认方式 例：Session入库实现例子 ① 先创建一个保存 Session 的数据表 1234567create database `sess_storage`;use `sess_storage`;create table `session` ( `id` varchar(255) primary key comment &#x27;SessionID&#x27;, `expires` int unsigned not null comment &#x27;过期时间&#x27;, `data` blog comment &#x27;数据&#x27;) ② 实现接口 创建 SessionDB.php文件，用于实现接口 12345678910class SessionDB implements SessionHandlerInterface&#123; private $link; public function open($savePath, $sessionName) &#123; /*处理语句*/ &#125;; public function close() &#123; /*处理语句*/ &#125;; public function write($id, $data) &#123; /*处理语句*/ &#125;; public function read($id) &#123; /*处理语句*/ &#125;; public function destroy($id) &#123; /*处理语句*/ &#125;; public function gc(int $maxlifetime) &#123; /*处理语句*/ &#125;;&#125; $link 用于保存数据库连接 实现 open 方法 接口里面的 open() 方法类似于类的构造方法，在会话打开的时候内调用 1234public function open($savePath, $sessionName) &#123; $this -&gt; link = new mysqli(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;123456&#x27;, &#x27;sess_storage&#x27;); return (bool) $this -&gt; link;&#125; 实现 close 方法 这类似于类的析构方法，在 write 方法调用完成之后调用。这里实现关闭数据库连接 123public function close() &#123; return $this -&gt; link -&gt; close();&#125; 实现 write 方法 将 Session 数据写入指定的位置，默认的情况下以文件的形式写进服务器中。以此方法修改保存到数据库中 1234567public function write($id, $data) &#123; $expires = time() + 3600; // 一小时的过期时间 $sql = &#x27;REPLACE INTO `session` SET `id` = ?, `data` = ?&#x27;; $stmt = $this-&gt;link-&gt;prepare($sql); $stmt = bind_param(&#x27;sis&#x27;, $id, $expires, $data); return (bool) $stmt-&gt;execute();&#125;; Session 数据表中的 ID 是 Session 的会话ID，是唯一的 在有效的时间内重复修改 Session 数据，使用 REPLACE 实现 read 方法 用于根据 Session 的会话ID 到指定位置获取 Session 数据并返回执行结果 12345public function read($id) &#123; $now = time(); $sql = &quot;SELECT `data` FROM `session` WHERE `id` = &#x27;$id&#x27; AND `expires` &gt; $now&quot;; return (string) $this-&gt;link-&gt;query($sql)-&gt;fetch_assoc()[&#x27;data&#x27;];&#125; 存在时直接返回结果，不存在返回空字符串 实现 destroy 方法 实现用于结束当前会话的同时，根据会话ID删除数据库中对应的 Session 信息 1234public function destroy($id) &#123; $sql = &quot;DELETE FROM `session` WHERE `id` = $id&quot;; return (bool) $this-&gt;link-&gt;query($sql);&#125; 实现 gc 方法 用于清理会话中的旧数据 12345public function gc(int $maxlifetime) &#123; $sql = &quot;DELETE FROM `session` WHERE (`expires` + $maxlifetime) &lt; $maxlifetime&quot;; $result = $this-&gt;link-&gt;query($sql); return (bool) $result;&#125; $maxlifetime 保存的是 php.ini 中 session.gc_maxlifetime 配置项指定的 Session 数据经过多长时间被视为垃圾而清除的秒数 完成 Session 入库设置 实现所有的抽象方法之后，利用 SessionDB 类的构造方法设置 Session 机制 123public function __construct() &#123; session_set_save_handler($this, true);&#125; 第一个参数：实现 SessionHandlerInterface 接口的对象 第 二个参数：true 表示将 session_write_close() 设置为 php 终止是执行的函数 测试 Session 入库 新建 test.php 文件，引入 SessionDB.php 文件，测试 Session数据是否保存在数据库中 1234require &#x27;./SessionDB.php&#x27;;new SessionDB(); // 配置Session入库session_start();$_SESSION[&#x27;test&#x27;] = &#x27;content&#x27;; 到数据库中查看到：test|s:7:&quot;content test：Session数据对应的 key 值 | 后 的 “s:7” 表示该数据是7为字符长度的字符串类型数据 content：Session数据 题外话[](￣▽￣)* Cookie 的一些关系 Cookie ：是一个请求头，其中含有先前由服务器通过Set-Cookie响应头投放并存储到客户端的 HTTP cookies Set-Cookie ：响应头，用来由服务器端向客户端发送 cookies HTTP Cookie ：也叫 Web Cookie 或者 浏览器 Cookie。是由服务器发送到用户浏览器并保存在本地的一小块数据（上面介绍的 Cookie 是这个） MDN 中是这样写的，在 MDN 中它们的目录关系是： Cookie ：HTTP &gt; HTTP Headers &gt; Cookie Set-Cookie ：HTTP &gt; HTTP Headers &gt; Set-Cookie HTTP Cookie ：HTTP &gt; HTTP cookies 所以，应该是这样的： Cookie 和 Set-Cookie 在 Web技术中是属于 Header，而HTTP Cookie，是Cookie的请求内容，是Set-Cookie的响应内容 在浏览器请求中就可以看到 Cookie 和 后面一大串字符串的 HTTP cookie 相关资料：MDN","categories":[{"name":"课堂学习","slug":"课堂学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php","slug":"php","permalink":"https://gitee.com/dsjerry/smalljerry/tags/php/"},{"name":"后端","slug":"后端","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Vuex学习","slug":"vuex学习","date":"2020-07-18T08:16:45.000Z","updated":"2020-07-21T09:00:16.363Z","comments":true,"path":"2020/07/18/vuex学习/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/18/vuex%E5%AD%A6%E4%B9%A0/","excerpt":"Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便地实现组件之间数据的共享 传统组件之间共享数据的方式： 父组件向子组件传值：v-bind 属性绑定 子组件向父组件传值：v-on 事件绑定 兄弟组件之间共享数据：EventBus $on：接收数据的组件 $emit：发送数据的组件 使用 Vuex 这个状态管理模式： 在 Vuex 中集中管理共享的数据，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在 Vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 什么时候应该使用 Vuex ？","text":"Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便地实现组件之间数据的共享 传统组件之间共享数据的方式： 父组件向子组件传值：v-bind 属性绑定 子组件向父组件传值：v-on 事件绑定 兄弟组件之间共享数据：EventBus $on：接收数据的组件 $emit：发送数据的组件 使用 Vuex 这个状态管理模式： 在 Vuex 中集中管理共享的数据，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在 Vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 什么时候应该使用 Vuex ？ 一般情况下组件之间共享数据才有必要使用 Vuex，如果是组件的私有数据，保存在组件自己的 data 中就好了 如果不是大型的单页面应用，使用 Vuex 可能是繁琐冗余的。简单的项目就不用使用了。 基本使用安装 Vuex 依赖包 npm install vuex --save 导入 12import Vuex from &quot;vuex&quot;Vue.use(Vuex) 创建 store 对象 12345const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;&#125;) 将 store 对象挂载到 Vue 实例中 123456new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(app), router, store&#125;) 也可以在脚手架直接创建 核心概念核心概念有：state、mutation、getter、action。要访问它们，各自都有两种方法，第一种是正常使用，第二种是在要使用数据的组件中导入 mapXXX函数 Statestate 提供唯一的公共数据源，所有共享的数据放到 store 中的 state 中。类似于 data 在 Vuex 的入口文件中创建 Vuex 对象后，创建 Vuex 对象 组件中要访问 state 中数据的 方法①： 1this.$store.state.全局数据名称 在插值表达式中使用上面代码时，this 可以省略 1&lt;h1&gt;数值：&#123;&#123; $store.state.count &#125;&#125;&lt;/h1&gt; 方法② 从 Vuex 中按需导入mapState 函数 1import &#123; mapState &#125; from &#x27;vuex&#x27; 然后通过这个导入的函数，将当前组件需要的全局数据映射为当前组件的计算属性 computed 123computed: &#123; ...mapState([&#x27;count&#x27;])&#125; ... 对象展开运算符 mapState 返回的是一个对象，要将它与局部计算属性混合使用，就需要将多个对象合并成一个。所以这里使用对象展开运算符 对象展开运算符（不知道怎么翻译，就这样吧） Reset Properties 12let &#123; x, y, ...z &#125; = &#123;x: 1, y: 2, a: 3, b: 4&#125;// x:1, y:2, z: &#123;a: 3, b:4&#125; Spread Properties 12let n = &#123;x, y, ...z&#125;n; // &#123;x: 1, y: 2, a: 3, b: 4&#125; 方法②例子 在需要的组件中引入 mapState 1import &#123; mapState &#125; from &#x27;vuex&#x27; 在当前组件中的计算属性定义 1...mapState( [&quot;count&quot;] ) 在 html 中使用（直接使用） 1&lt;h3&gt;&#123; count &#125;&lt;/h3&gt; Mutation更改 Vuex 的 store 中的状态（数据）的唯一方法是提交 mutation。类似于事件 定义在 Vuex 的入口文件中 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; // 没有参数 add(state) &#123; state.count++ &#125;， // 携带参数 addN(state, step)&#123; state.count += step &#125; &#125;&#125;) 触发有两种方法：this.$store.commit() 和 mapMutations 方法① 在 要使用到的组件 里面 里面先要有对应的事件处理函数，比如 addBtn 事件 12345678methods: &#123; addBtn() &#123; this.$store.commit(&quot;add&quot;) &#125;, addNBtn() &#123; this.$store.commit(&quot;addN&quot;, 3) &#125;&#125; commit 里面对应的参数就是在 mutation 里面定义的内容 方法② 从需要的组件中按需导入 mapMutations 函数 1import &#123; mapMutations &#125; from &#x27;vuex&#x27; 通过展开运算符将 mutations 中的函数映射为当前组件中的 methods 123methods: &#123; ...mapMutations( [&#x27;add&#x27;, &#x27;addN&#x27;] )&#125; 然后在 methods 中加入对应的时间处理函数，比如是页面的 addBtn 和 addNBtn 123456789methods: &#123; ...mapMutations( [&#x27;add&#x27;, &#x27;addN&#x27;] ), addBtn() &#123; this.add() &#125;, addNBtn() &#123; this.addN(3) &#125;&#125; 其实是可以直接调用映射来的方法的，因为它本来就是映射过来的方法，不用在另外的方法里面调用也行 ActionAction 类似于 Mutation，但用于处理异步操作，是通过触发 Mutation 来修改数据 定义12345678910111213141516171819202122232425const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; add(state) &#123; state.count++ &#125;, addN(state, step) &#123; state.count += step &#125; &#125;, actions: &#123; addAsync(context) &#123; setTimeOut( () =&gt; &#123; context.commit(&quot;add&quot;) &#125;, 1000 ) &#125;, addNAsync(context, step) &#123; setTimeOut( () =&gt; &#123; context.commit(&quot;addN&quot;, step) &#125;, 1000 ) &#125; &#125;&#125;) 这里的 commit 中的函数只能是在 mutation中的函数，使用 context 来调用 触发方法① 在需要使用的组件中 12345678methods: &#123; addBtn() &#123; this.$store.dispatch(&quot;addAsync&quot;) &#125;, addNBtn() &#123; this.$store.dispatch(&quot;addNAsync&quot;, 3) &#125;&#125; 方法② 导入模块 mapActions 1import &#123; mapActions &#125; from &#x27;vuex&#x27; 将需要的函数映射为当前组件的 methods 123456789methods: &#123; ...mapActions( [&#x27;addAsync&#x27;, &#x27;addNAsync&#x27;] ) addBtnAsync() &#123; this.addAsync() &#125; addNBtnAsync() &#123; this.addNasync(3) &#125;&#125; 也可以直接使用，不用另外再在页面声明一个事件处理函数来调用 直接调用 ...mapActions 映射过来的方法 1&lt;button @click=&quot;addNAsync(3)&quot;&gt;加N&lt;/button&gt; Getter有时候我们需要从 store 中的 state 中派生出一些状态(数据)，getter 就是对 store 中的数据进行加工后形成新的数据，类似于计算属性 store 中的数据发生变化，getter 的数据也会跟着变化 定义在 Vuex 的入口文件中 12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, getters: &#123; showNum: function(state) &#123; return &#x27;当前的数值是&#x27; + state.count &#125; &#125;&#125;) 触发方法① 1this.$store.getters.名称 方法② 使用 mapGetters 1import &#123; mapGetters &#125; from &#x27;vuex&#x27; 映射在当前的计算属性中 123computed: &#123; ...mapGetters( [&#x27;showNum&#x27;] )&#125; 例如 1234&lt;!--正常使用数据--&gt;&lt;h3&gt;当前的数值是：&#123;&#123; $store.state.count &#125;&#125;&lt;/h3&gt;&lt;!--使用 mapGetters 的时候--&gt;&lt;h3&gt;&#123;&#123; showNum &#125;&#125;&lt;/h3&gt; 案例代码Github","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vuex/"}]},{"title":"JS一些笔记","slug":"JS一些笔记","date":"2020-07-12T02:58:32.000Z","updated":"2020-07-21T08:59:38.333Z","comments":true,"path":"2020/07/12/JS一些笔记/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/07/12/JS%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/","excerpt":"js会用到集合，每次遇到但可能又忘记了什么原理怎么用的一些乱七八糟的东西。 持续更新 ~ Array 对象forEach()用来调用数组的每个元素，并将元素传递给回调函数。 用在空数组中是不会执行回调函数的。 1array.forEach( function (item, index, arr), thisValue) item：当前元素，即是每次循环对应的那个值。必选 index：当前元素的索引值。可选 arr：当前元素所属的数组对象 thisValue：算了，用到再说，现在不知道怎么用","text":"js会用到集合，每次遇到但可能又忘记了什么原理怎么用的一些乱七八糟的东西。 持续更新 ~ Array 对象forEach()用来调用数组的每个元素，并将元素传递给回调函数。 用在空数组中是不会执行回调函数的。 1array.forEach( function (item, index, arr), thisValue) item：当前元素，即是每次循环对应的那个值。必选 index：当前元素的索引值。可选 arr：当前元素所属的数组对象 thisValue：算了，用到再说，现在不知道怎么用 12345var array = [1, 3, 6, 9, 12];array.forEach(function (item, index, arr) &#123; console.log(item);&#125;);// 分别输出 1, 3, 6, 9, 12 some()用于检测数组中的元素是否满足指定条件 会依次执行数组的每个元素 如果有一个满足条件。表达式返回 true ，剩余的元素不会执行 如果没有满足条件的元素，返回 false 不会执行空数组，不会改变原来的数组 1234567var array = [1, 3, 6, 9, 12];array.some(function (item, index, arr) &#123; if (item &gt; 3) &#123; console.log(item); &#125;&#125;);// 分别输出 1，9，12 String 对象split()将一个字符串分割为字符串数组 如果传入空字符串作为第一个参数，那每个字符之间都会分割 不改变原始的字符串 1string.split(jerry, limit) jerry：可选，字符串或正则表达式 limit：可选。指定返回数组的最大长度 1234567var str = &quot;Are you OK ?&quot;;console.log(str.split());// 输出结果：[&quot;Are you OK ?&quot;]console.log(str.split(&quot;&quot;));// 输出结果：[&quot;A&quot;, &quot;r&quot;, &quot;e&quot;, &quot; &quot;, &quot;y&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;, &quot;O&quot;, &quot;K&quot;, &quot; &quot;, &quot;?&quot;]console.log(str.split(&quot; &quot;));// 输出结果：[&quot;Are&quot;, &quot;you&quot;, &quot;OK&quot;, &quot;?&quot;]","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitee.com/dsjerry/smalljerry/tags/js/"}]},{"title":"python爬虫基础","slug":"python爬虫基础","date":"2020-06-30T12:07:42.000Z","updated":"2020-07-21T09:00:07.177Z","comments":true,"path":"2020/06/30/python爬虫基础/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/06/30/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","excerpt":"爬虫：模拟客户端（浏览器），发送网络请求 入门阶段，还有很多东西需要深究、探索 前提要知道 url = 请求协议 + 网站的域名 + 资源的路径 + 参数 浏览器请求的 url 地址，拿到的 response 里面有一些 js、css、html等内容。也就是所一条 url 请求返回的东西有很多 浏览器中 element 中的内容和爬虫中获得的 url 地址响应不同，所以需要以当前的 url 地址对应的响应为准。在 network 中可以找到，点击里面的response（页面上点击右键显示网页源码 http：超文本传输协议。以明文的形式传输，效率高但是不安全 https：http + ssl（安全套接字层 传输之前数据加密，后来再通过解密获取内容。效率低但是安全","text":"爬虫：模拟客户端（浏览器），发送网络请求 入门阶段，还有很多东西需要深究、探索 前提要知道 url = 请求协议 + 网站的域名 + 资源的路径 + 参数 浏览器请求的 url 地址，拿到的 response 里面有一些 js、css、html等内容。也就是所一条 url 请求返回的东西有很多 浏览器中 element 中的内容和爬虫中获得的 url 地址响应不同，所以需要以当前的 url 地址对应的响应为准。在 network 中可以找到，点击里面的response（页面上点击右键显示网页源码 http：超文本传输协议。以明文的形式传输，效率高但是不安全 https：http + ssl（安全套接字层 传输之前数据加密，后来再通过解密获取内容。效率低但是安全 前提知识http协议 - 请求 请求行：浏览器中可以找到的那个request 请求头 user-agent：用户代理，服务器通过这个知道在请求资源的是什么设备、平台、浏览器 如果是模拟手机来请求服务器，就得使用手机的 user-agent cookie：用来存储用户信息，每次请求都传给服务器 一般在面对要登录的页面的时候会使用到cookie 这样就在一定程度上防止浏览器知道是在爬虫 请求体：get 请求没有，post 请求有 就是携带数据的，get 请求的数据在 url 上，post 的数据在请求体里 post能携带的数据量比较大，t一般用于登录注册、用于传输大文本的时候 http响应 响应头：set-cookie，对方服务器通过这个字段设置cookie到本地 等号前的是 cookie 的 name ，后的是 cookie 的 value，分号等额每一条 cookie 响应体：url 地址对应的响应 requestspython 爬虫的关键所在，第三方模块。 安装： 1$ pip install requests 使用：直接引入 1import requests 发送 get、post 请求 response = requests.get( url ) response = requests.post( url, data={ 请求体的字典 } ) 1234567891011url = &quot;xxxxx&quot;query_string = &#123; &quot;xxx&quot;: &quot;zzz&quot;, &quot;hhh&quot;: &quot;sss&quot;&#125;headers = &#123; &quot;user-agent&quot;: &quot;qweasdzxc&quot;, &quot;cookie&quot;: &quot;ahhxixilala&quot;&#125;response = requests.post(url, data=quert_string, headers=headers)print(response.content.decode()) 除了使用 cookie 来记录用户，还可以使用 session 来记录用户 response的方法 response.text()：这个方法如果出现乱码，就使用 response.encoding=&quot;utf-8&quot; 12345# 获取网页的html字符串response = requests.get(url)# 返回的是随机的编码，一般情况下直接 .text 可以得到，如果不行，就加上这个编码response.encoding = &quot;utf-8&quot;print(response.text) response.content.decode()：把响应的二进制字节流转化为 str 类型 response.request.url：发送请求的 ur l地址 response.url：response响应的url地址 response.request.headers：请求头 response.headers：响应请求 获取源码的方式（这三种方式一定能获得网页正确解码后的字符串） response.content.decode() response.content.decode(“gbk”) response.text requests.session这里是使用了 session 来代替了 cookie 实例化session 1session = requests.session() 例子 123456789101112131415# 使用 session 发送 post 请求，获取服务器在本地保存的 cookie，比如登录post_url = &quot;xxxssswww&quot;headers = &#123; &quot;user-agent&quot;: &quot;zxcasdqwe&quot;&#125;post_data = &#123;&quot;username&quot;: &quot;jerry&quot;, &quot;password&quot;: &quot;123456&quot;&#125;session.post(post_url, headers=headers, data=post_data)# 可再次使用session，请求登录之后的页面url = &quot;xxxxxx&quot;response = session.get(url, headers=headers)# 将内容保存到一个新的文件with open(&quot;test.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(response.content.decode()) 数据提取方法json一种数据交换的格式，一般吧网页切换成 手机版 会返回 json 类型的数据。导入：import json，内部模块，不需要使用 pip 下载 json.load 把 json 字符串转化为 python 类型 json.load(json字符串) json.dumps 把 python 类型转化为字符串 json.dumps( { } ) json.dumps( val, ensure_ascii=False, indent=2 ) ensure_ascii=False：让中文显示成中文，False首字母要大写 indent：让下一行在上一行的基础上空格 xpath 和 lxmlxpath ​ xpath helper ：一款浏览器插件，可以在浏览器的 elements中定位数据 使用方法： /html/head/meta：选中 html 中 head 下的所有 meta 标签 // ：从任意节点开始选择 //li ：当前页面上的所有 li 标签 /html/head//link ：head 下的所有 link 标签 @ 选择具体某个元素：//div[@class=&#39;app&#39;]/ul/li（选择了class名为 app 下的 ul 下的 li） @a/@href：选择 a 标签下的 href 值 获取文本： /a/text()：获取 a 下面的文本 /a//text()：获取 a 下面的所有文本 . ./a ：当前节点下的 a 标签 lxml 安装：$ pip install lxml 使用： 123from lxml import etreeelement = etree.HTML(&quot;html字符串&quot;)element.xpath(&quot;&quot;) 例如1 12345html_str = response.content.decode()html = etree.HTML(html_str)print(html)img_list = html.xpath(&quot;//div[@class=&#x27;indent&#x27;]/div/table//a[@class=&#x27;nbg&#x27;]/img/@src&quot;) # 获取某个页面内的图片print(img_list) 例如2，获取网页上的多种类型数据(接上) 1234567891011ret1 = html.xpath(&quot;//div[@class=&#x27;indent&#x27;]/div/table&quot;) # 设置前缀，后面的使用就不需要重新写这些相同的部分print(ret1)for table in ret1: item = &#123;&#125; # 起初是得到很多数据，后面使用[0].replace.....过滤数据，当然可以使用其他办法，这里使用这个简单的方法 # [0] 所示投机取巧，不是什么时候都能用 item[&quot;title&quot;] = table.xpath(&quot;.//div[@class=&#x27;pl2&#x27;]/a//text()&quot;)[0].replace(&quot;/&quot;, &quot;&quot;).strip() item[&quot;href&quot;] = table.xpath(&quot;.//div[@class=&#x27;pl2&#x27;]/a/@href&quot;)[0] item[&quot;img&quot;] = table.xpath(&quot;.//a[@class=&#x27;nbg&#x27;]/img/@src&quot;)[0] item[&quot;comment_num&quot;] = table.xpath(&quot;.//span[@class=&#x27;pl&#x27;]/text()&quot;)[0] print(item) strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列 例子前提安装：requests，lxml 网页数据的结构可能已经改变，了解爬虫思路就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsfrom lxml import etreeimport json&#x27;&#x27;&#x27;先定义好思路，然后将思路变成具体的实现方法&#x27;&#x27;&#x27;class QiuShi: def __init__(self): self.url_temp = &quot;https://www.qiushibaike.com/text/page/&#123;&#125;/&quot; self.headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, &quot; &quot;like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot;&#125; def get_url_list(self): url_list = [self.url_temp.format(i) for i in range(1, 14)] return url_list def parse_url(self, url): response = requests.get(url, headers=self.headers) return response.content.decode() def get_content_list(self, html_str): html = etree.HTML(html_str) # 1. 分组 div_list = html.xpath(&quot;//div[@id=&#x27;content-left&#x27;]/div&quot;) content_list = [] for div in div_list: item = &#123;&#125; item[&quot;author_name&quot;] = div.xpath(&quot;./h2/text()&quot;)[0] if len(div.xpath(&quot;./h2/text()&quot;) &gt; 0) else None item[&quot;content&quot;] = div.xpath(&quot;.//div[@class=&#x27;content&#x27;]/span/text()&quot;) item[&quot;stats_vote&quot;] = div.xpath(&quot;.//span[@class=&#x27;stats_vote&#x27;]/i/text()&quot;) item[&quot;stats_vote&quot;] = item[&quot;stats_vote&quot;][0] if len(item[&quot;stats_vote&quot;]) &gt; 0 else None content_list.append(item) return content_list def save_content_list(self, content_list): with open(&quot;qiubai.txt&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;) as f: for content in content_list: f.write(json.dumps(content, ensure_ascii=False)) f.write(&quot;\\n&quot;) print(&quot;保存成功&quot;) def run(self): &quot;&quot;&quot;实现主要逻辑&quot;&quot;&quot; # 1. 根据url的规律，构造url list url_list = self.get_url_list() # 2. 发送请求，获取响应 for url in url_list: html_str = self.parse_url(url) # 3. 提取数据 content_list = self.get_content_list(html_str) # 4. 保存 self.save_content_list(content_list)if __name__ == &#x27;__main__&#x27;: qiushi = QiuShi() qiushi.run() 小结 知道要爬取的url和url的规律，比如翻页什么的、 使用 requests 发送请求，获取响应 提取数据 返回json字符串，使用 json 模块 返回的是 html 字符串，使用 lxml 模块 搭配 xpath 提取数据 保存数据 加油，脚踏实地。","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/dsjerry/smalljerry/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"PHP面向对象进阶","slug":"PHP面向对象进阶","date":"2020-06-26T13:56:03.000Z","updated":"2020-07-21T08:59:56.766Z","comments":true,"path":"2020/06/26/PHP面向对象进阶/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/06/26/PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/","excerpt":"这篇包括类常量、静态成员、封装、继承、接口 类常量与静态成员如果希望类中定义的成员被所有对象共享，可以使用类常量或静态成员来实现 类常量 定义后的类常量值不变，在类中使用 const 关键字定义类常量 1const 类常量名 = &quot;常量值&quot;; 在访问类常量的时候，使用格式 类名::常量名称 ，**::** 称为范围解析操作符 1234class Student&#123; const SCHOOL = &quot;火星学院&quot;;&#125;echo Student::SCHOOL; 在类内也可以访问类常量，使用 self 关键字代替类名 如 self::SCHOOL ，这样避免了修改类名之后要修改类中的代码的麻烦","text":"这篇包括类常量、静态成员、封装、继承、接口 类常量与静态成员如果希望类中定义的成员被所有对象共享，可以使用类常量或静态成员来实现 类常量 定义后的类常量值不变，在类中使用 const 关键字定义类常量 1const 类常量名 = &quot;常量值&quot;; 在访问类常量的时候，使用格式 类名::常量名称 ，**::** 称为范围解析操作符 1234class Student&#123; const SCHOOL = &quot;火星学院&quot;;&#125;echo Student::SCHOOL; 在类内也可以访问类常量，使用 self 关键字代替类名 如 self::SCHOOL ，这样避免了修改类名之后要修改类中的代码的麻烦 静态成员 使用 static 关键字来修饰静态成员，属于类的成员 通过类名直接访问，不需要实例化对象 1234567891011class Student&#123; public static $msg; public static function show()&#123; echo &#x27;信息：&#x27; . self::$msg; // 类内访问静态属性 &#125; public static function test()&#123; self::show(); // 类内调用静态方法 &#125;&#125;Student::$msg = &#x27;PHP学习&#x27;; // 类外访问静态属性Student::show(); // 类外调用静态方法 继承和封装为了保护数据不被调用者随意修改、防止重复定义 继承 在现有的类的基础上去构造一个新的类。这个新类叫作 子类，原有的类叫作 父类 使用 extends 关键字 只允许单继承，即是每个子类只能有一个父类 12345678910111213class Animal&#123; public $name; public function shout()&#123; echo $this -&gt; name . &#x27;发出叫声&#x27;; &#125;&#125;class Cat extends Animal&#123; public function __construct($name)&#123; $this -&gt; name = $name; &#125;&#125;$cat = new Cat(&quot;Tom&quot;);$cat -&gt; shout(); // Tom发出叫声 当子类有和父类相同名字的成员的时候，子类成员会覆盖父类成员 traits 关键字 使得PHP可以自由复用成员属性和方法，减少单继承的限制 12345678910111213class Animal&#123;&#125;trait Cat&#123; public function shout()&#123; echo &quot;喵喵&quot;; &#125;&#125;class TomCat extends Animal&#123; use Cat; public function __construct()&#123; $this -&gt; shout(); &#125;&#125;$tom = new TomCat(); // 输出结果：喵喵 当子类、父类、traits有相同名称的成员的时候，优先级是：子类 &gt; traits &gt; 父类 可以给 traits 中同名的成员取别名，例如有 Cat 和 Dog 两个Traits 中有相同的 shout() 1234use Cat, Dog&#123; Cat::shout insteadof Dog; // 将左边的 Trait 指定的成员代替给右边 Dog::shout as cry; // 将右边指定的成员名代替左边的&#125; 当执行 cry()，的时候，实际上是执行 Dog中的 shout() 封装 隐蔽程序内部的细节，仅对外开放接口 类的封装通过访问控制修饰符实现的 public：公有修饰符（同一类内、子类、类外 可访问） protected：保护成员修饰符（同一类内、子类 可访问） private：私有修饰符（同一类内 可访问） 在PHP 4 中的所有属性都是用 var 声明的，效果和 public 一样，以后的版本也兼容，但是会转换为 public 123456class User&#123; public $name = &#x27;jerry&#x27;; protected $tel = &quot;16888&quot;; private $age = 18;&#125; 要想访问到 protected 和 private 的成员，有两种方法：公有方法，魔术方法 公有方法 在一个类中声明一个公有方法，然后通过这个公有方法访问。例如：在上面 User 类中加入 123public function test()&#123; return $this -&gt; age;&#125; 然后调用 123$user = new User();echo $user -&gt; age; // 无法访问到私有属性echo $user -&gt; test(); // 可以访问到age 魔术方法 待整理…… 方法重写 重写方法时，要保持参数数量一致 子类中方法的访问级别等于或者小于父类中被重写的方法的访问级别 非静态方法重写123456789101112class Person&#123; public function introduce()&#123; echo __CLASS__; &#125;&#125;class Student extends Person&#123; public function introduce()&#123; echo __CLASS__; &#125;&#125;$s1 = new Student();$s1 -&gt; introduce(); // 输出结果：Student 魔术常量 __CLASS__ 用于返回当前被调用的类名 私有成员只能在本类内访问，所以父类的私有属性成员不能被重写 静态方法重写对静态成员的调用除了可以使用类名，还可以使用self、parent、static 关键字代替 self：获取当前方法调用时所在的类 parent：获取当前类的父类 static：获取实际运行时方法所在的类，也称为后期静态绑定 12345678910111213141516171819class Person&#123; public function show()&#123; self::introduce(); // 优先访问父类方法 static::introduce(); // 优先访问子类方法 &#125; public static function introduce()&#123; echo &#x27;[Person]&#x27;; &#125;&#125;class Student extends Person&#123; public function show()&#123; parent::show(); // 子类调用父类方法 &#125; public static function introduce()&#123; echo &#x27;[Student]&#x27;; &#125;&#125;$s1 = new Student();$s1 -&gt; show(); // 输出结果： [Person][Student] final 关键字被 final 关键字修饰的类和成员方法不能被修改，final 类不能被继承，只能被实例化。 12345678class Person&#123; protected final function show()&#123; // final 方法不能被子类重写 &#125;&#125;final class Student extends Person&#123; // final 类不能被继承，只能被实例化&#125; 在代码上告诉了别人，在这里已经结束了，在代码层面上限制了类的使用方式，从而减少不必要的沟通 抽象类和接口在项目来发中，经常需要定义方法来描述类的一些行为特征，但是这些行为特征在不同的情况之下又有不同的特点。所以在这种无法确定的情况下，就要使用抽象类和接口 抽象类与抽象方法抽象类用来定义某种行为，但是具体的实现需要 子类 来完成。使用 abstract 关键字来修饰抽象类 比如跑步这个行为，有恢复跑、基础跑、长跑等多种跑步方式 123abstract class 类名&#123; // 定义抽象类 public abstract function 方法名(); // 定义抽象方法&#125; 在使用的时候需要注意： 抽象方法是只有方法声明而没有方法体的特殊方法 含有抽象方法的类必须被定义为抽象类 抽象类中可以有非抽象方法、成员属性和常量 抽象类不能被实例化，只能被继承 子类继承抽象类时必须实现抽象方法，否则也必须定义成抽象方法有下一个继承实现 抽象类中的抽象方法被声明为 protected，那么子类中实现的方法可以声明为 protected 或者是 public，而不能是 private。就是说范围变大了 12345678910abstract class sport&#123; public abstract function type();&#125;class Run extends sport&#123; public function type()&#123; echo &quot;长跑&quot;; &#125;&#125;$running = new Run();$running -&gt; type(); // 输出结果：长跑 在使用继承抽象类的子类中，还可以添加其他东西。。但是在实现的时候，参数必须和定义抽象方法的参数一样 抽象实现了，当然就不用抽象啦 接口如果抽象类中的 所有 方法都是 抽象方法，那这个类就叫做接口，关键字interface 在接口中，所有的方法只能是公有的，不能使用 final 关键字来修饰 123interface 接口名&#123; public function 方法名();&#125; 记得！没有具体的函数体！ 因为接口所有方法都是抽象的，所以省略掉 abstract 关键字 接口方法体没有具体实现，所以需要通过某个类使用 implements 关键字来实现接口 12345678910111213141516interface ComInterface&#123; public function connect(); public function transfer(); public function disconnect();&#125;class MobilePhone implements ComInterface&#123; public function connect()&#123; echo &quot;连接&quot;; &#125; public function transfer()&#123; echo &quot;传输&quot;; &#125; public function dsiconnect()&#123; echo &quot;断开连接&quot;; &#125;&#125; MobilePhone 类中必须实现 ComInterface 接口中定义的所有方法 一个类可以实现多个接口，用逗号隔开，但是接口中的方法不能重命名 接口中可以定义常量，与类常量用法相同，但是不能被子类或子接口覆盖 类也可以在继承的时候实现接口 123class MobilePhone extends Phone implements ComInterface&#123; &#125; extends 和 implements 的区别 extends：继承一个类来创建子类 implements：一个类通过这个关键字声明自己使用一个或多个接口，要通过重写才能实现 继承之后使用多个接口： 1class A extends B implements C,D,E 我感觉就是，extends 使用在不是全是抽象类的地方，可以实现普通继承，也可以实现接口继承，不过就是还不在接口的范畴之内，若果这个类里面都是抽象方法，那就是接口了，所以就要使用 implements 多态与类型约束 多态：实现同一操作作用于不同的对象，产生不同的执行效果 类型约束：在成程序实现多态时限制传入的参数必须是某个类或接口 获取商品价格 123function price(Goods &amp;g)&#123; return $g -&gt; getName() . &#x27;的价格是&#x27; . $g -&gt; getPrice();&#125; $g 表示用户传入的具体商品对象 为了保证每一个传入的对象必须含有 getName() 方法和 getPrice() 方法，将参数 $g 的类型指定为 Goods 接口 定义接口 1234interface Goods&#123; public function getName(); public function getPrice();&#125; 实现接口 12345678910111213141516171819// 定义 Phone 类实现 Goods接口class Phone implements Goods&#123; public function getName()&#123; return &#x27;手机&#x27;; &#125; public function getPrice()&#123; return &#x27;2000&#x27;; &#125;&#125;// 定义 Computer 类实现 Goods 接口class Computer implements Goods&#123; public function getName()&#123; return &#x27;电脑&#x27;; &#125; public function getPrice()&#123; return &#x27;6000&#x27;; &#125;&#125;// 等等。。。。实现Goods接口 向 price() 里面传入不同的 商品对象 ，就可以得到对应商品的价格 1234// 实例化商品类$goods = new Phone();// 获取对应的商品价格，输出结果：手机的价格是2000price( $goods ); 总的来说就是：有接口，实现接口，实例化对象，通过函数使用","categories":[{"name":"课堂学习","slug":"课堂学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://gitee.com/dsjerry/smalljerry/tags/PHP/"}]},{"title":"PHP 面向对象-类与对象的使用","slug":"PHP面向对象","date":"2020-06-25T13:26:07.000Z","updated":"2020-07-21T08:59:35.018Z","comments":true,"path":"2020/06/25/PHP面向对象/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/06/25/PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"和面向对象编程语言有所不同，PHP不是一种纯面向对象语言。但随着发展，PHP也向着这方面发展 面向对象的特征 封装性：将对象的属性和行为封装起来，不需要让外界知道具体的细节 继承性：主要描述类与类之间的关系；不需要重写原有类的代码，对原有类的功能进行扩展，提高代码的复用性、增强开发效率 多态性：指同一操作作用于不同对象，会产生不同的结果。大概就是一个类可以产生不同的对象 类的定义和实例化12345678class Animal&#123; public $name; public function shout()&#123; echo &quot;哈哈哈&quot;; &#125;&#125;// 实例化（创建对象）$person = new Animal();","text":"和面向对象编程语言有所不同，PHP不是一种纯面向对象语言。但随着发展，PHP也向着这方面发展 面向对象的特征 封装性：将对象的属性和行为封装起来，不需要让外界知道具体的细节 继承性：主要描述类与类之间的关系；不需要重写原有类的代码，对原有类的功能进行扩展，提高代码的复用性、增强开发效率 多态性：指同一操作作用于不同对象，会产生不同的结果。大概就是一个类可以产生不同的对象 类的定义和实例化12345678class Animal&#123; public $name; public function shout()&#123; echo &quot;哈哈哈&quot;; &#125;&#125;// 实例化（创建对象）$person = new Animal(); 对象的基本使用成员操作创建对象之后，使用 对象 -&gt; 成员 来访问属性和方法 成员属性 1234567891011// 访问并赋值$person-&gt;name = &quot;张三&quot;;// 删除属性值unset($person-&gt;name);// 判断属性是否设置值isset($person-&gt;name);// 判断属性是否被定义property_exists(&#x27;Animal&#x27;, &#x27;name&#x27;); 属性值为 null 或使用 unset( ) 删除后的 isset() 结果都是 false。unset() 删除的只是属性值，属性还在的 成员方法 1$person-&gt;shout(); 特殊变量 $this 代表当前对象，用于完成对象内部成员之间的访问。只能在类定义的方法内使用，不能在类外使用 12345678class Human&#123; public $name = &quot;张三&quot;; public function say($val)&#123; echo $this-&gt;name.$val.&quot;哈哈哈&quot;; &#125;&#125;$person = new Human();$person-&gt;say(&quot;说&quot;); 这里的 $this 代表的是 $person 对象 可变类和可变成员 与可变变量和可变函数类似，就是取个别名的意思 声明一个新的变量来接收值，这值是类名、属性名、方法名的字符串形式 12345678910$humanbeing = &#x27;Hunman&#x27;;// 实例化对象$person = new $humanbeing();// 访问属性$beCall = &#x27;name&#x27;;echo $person -&gt; $beCall;// 调用方法$shout = &#x27;say&#x27;;$person -&gt; $shout(&quot;okok&quot;); 在访问的时候 -&gt; 后面跟的是$变量名称，是要加上 $ 的 链式调用一个函数的返回值是一个对象的时候，可以在前一个调用的后面继续调用其返回的对象中的方法 12345678910111213class Goods&#123; public $name = &quot;电脑&quot;; public function start()&#123; echo &quot;开机&quot;; return $this; &#125; public function open()&#123; echo &quot;打开应用&quot;; return $this; &#125;&#125;$computer = new Goods();echo $computer -&gt; name -&gt; start() -&gt; open(); 对象的特殊操作符 判断两个对象是否相等，使用 == 或 === == ：同一个类的实例，且属性和属性值相等 === ：必须是同一个实例 12345678910class Test&#123; public $flag;&#125;$a = $b = new Test();$c = new Test();var_dump( $a == $b ); // 输出结果：bool(true)var_dump( $a == $c ); // truevar_dump( $a == $c ); // truevar_dump( $a === $b ); // truevar_dump( $a === $c ); // false 使用 instanceof 关键字判断对象是否是某个对象的实例 12var_dump( $a instanceof Test ); // truevar_dump( $a instanceof other); // false 对象克隆12345678class Test&#123; public $flag = 1;&#125;$a = new Test();$b = $a;$a -&gt; flag = 3;var_dump( $a -&gt; flag ); // int(3)var_dump( $b -&gt; flag ); // int(3) 修改 $a 的值，$b 也会跟着改变，要想的到多个 全等(===) 对象并且它们的值不相互影响，使用 clone 关键字 123$b = clone $a;var_dump( $a -&gt; flag ); // int(3)var_dump( $b -&gt; flag ); // int(1) 在对象克隆的时候，如果想对新的对象的某些属性进行初始化，可以使用 魔术方法 __clone 在调用了 clone 的时候就会自动执行 __clone 魔术方法：不需要手动调用，在某些时刻自动执行 PHP中所有的魔术方法都是以 __ （两个下划线）开头。 在 Test 类中加入 123public function __clone()&#123; $this -&gt; flag = &#x27;xixi&#x27;;&#125; 所以 如果不改变 a 对象的值，它就是原本的值 给 a 赋了新的值，a 的值就会改变 b 要是不想随着 a 改变，就要使用 clone 关键字 使用 clone 之后的 b，它的值就是原本的值 1 如果要想自定义使用 clone 后 b 的值，就要使用 __clone 构造方法和析构方法构造方法 每一个类都有一个构造方法，在创建对象时自动调用。主要用于在创建对象的时候初始化功能 如果在类中没有显式的声明它，PHP会自动生成一个什么都没有的构造方法 123function __construct()&#123; // 初始化操作&#125; 默认情况下是 public ，可以省略 1234567891011class Person&#123; public $name; public function __construct($name = &quot;xxx&quot;)&#123; $this -&gt; name = $name; &#125; public function show()&#123; echo $this -&gt; name.&quot;正在吃饭&quot;; &#125;&#125;$p1 = new Person(&quot;李四&quot;); // 张三正在吃饭$p2 = new Person(); // xxx在吃饭 使用构造函数就可以实现传递不同的参数来实例不同的对象，这样就不用建立好多个类了 析构方法 在对象被销毁之前自动调用，可以用作关闭文件、释放结果集等 在使用 unset() 的时候 或 PHP脚本执行结束自动释放对象时，自动执行 1234567class Student&#123; public function __destruct()&#123; echo &#x27;正在执行析构方法&#x27;; &#125;&#125;$xiaoming = new Student();unset( $xioaming ); // 这时候就会执行，输出结果 不使用 unset 的话，例如在函数中实例化对象 1234function test()&#123; $xioaming = new Student();&#125;test(); // 函数执行结束，自动执行析构方法 如果不希望对象在函数结束的手就被销毁，可以使用 返回值 接收对象 匿名类……","categories":[{"name":"课堂学习","slug":"课堂学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://gitee.com/dsjerry/smalljerry/tags/PHP/"}]},{"title":"express&mysql 搭建api","slug":"express-mysql-搭建api","date":"2020-05-29T05:02:07.000Z","updated":"2020-07-21T08:59:44.161Z","comments":true,"path":"2020/05/29/express-mysql-搭建api/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/05/29/express-mysql-%E6%90%AD%E5%BB%BAapi/","excerpt":"还在基础阶段，还有很多方面需要学习和优化 以下配置可以实现基础的 express 搭建服务器和处理客户端的请求 express 应用程序生成器 通过 express-generator 快速创建一个应用骨架 1$ npx install express-generator 或者是旧版本的 node，使用： 12$ npm install -g express-generator$ express 启动服务 1$ npm start","text":"还在基础阶段，还有很多方面需要学习和优化 以下配置可以实现基础的 express 搭建服务器和处理客户端的请求 express 应用程序生成器 通过 express-generator 快速创建一个应用骨架 1$ npx install express-generator 或者是旧版本的 node，使用： 12$ npm install -g express-generator$ express 启动服务 1$ npm start 基本目录结构 bin：原始的入口文件目录，后面会改掉 public：放一些静态资源的地方，图片、介绍、、css之类的 routes：路由文件位置 views：静态页面位置 app.js：在根目录下作为入口文件 改写入口文件 起初，入口文件是在 bin 目录下的 www.js 将 www.js 里面的 http、server 模块转移到 app.js ，app.js 里面的暴露去掉，添加一个监听端口 使用express路由作为中间件，接收和处理来自客户端的请求。路由都放在 routes 目录下。 1234567891011var express = require(&quot;express&quot;);var router = express.Router();router.get(&quot;/&quot;, (req, res, next) =&gt;&#123; // 返回内容给客户端 res.send()&#125;)router.post(&quot;/login&quot;, (req, res, next) =&gt;&#123; // post 请求的内容在 res.body 对象中 var data = req.body; console.log(data);&#125;) 安装mysql 模块1$ npm install mysql --save 连接数据库数据库配置可以在根目录建一个文件夹，名字随便但最好是顾名思义。例如 dbConfig 创建文件 config.js 用来保存连接数据库时所要用到的信息 12345678const DB = &#123; host: &quot;主机名&quot;, port: &quot;端口&quot;, user: &quot;用户名&quot;, password: &quot;密码&quot;, database: &quot;数据库&quot;&#125;;module.exports = DB; 同目录下创建 database.js 连接数据库 1234567891011121314const mysql = require(&quot;mysql&quot;);const config = require(&quot;./config&quot;);// 创建连接const database = mysql.createConnection(&#123; host: config.host, port: config.port, user: config.user, password: config.password, database: config.database&#125;);// 连接mysqldatabase.connect();module.exports = database; 连接的同时可以做别的事情 123456database.connect( err =&gt; &#123; if (err) console.log(err); else console.log(&quot;sucessful&quot;)&#125;); 数据库使用1234database.query(&quot;select * from xxx&quot;, (err, rows, fields) =&gt; &#123; if (err) throw err; console.log(&quot;查询结果：&quot; + rows);&#125;) err ：错误信息、rows ：查询结果、fields ：当前查询中涉及到的字段信息，一般很少用到 router 搭配 mysql 处理客户端的请求 在 routes 文件夹中的路由文件中，例如在 index.js 中 12345678910111213var express = require(&quot;express&quot;);var router = express.Router();var db = require(&quot;../dbConfig/database&quot;);// 此处使用 / 来表示当前路由文件，因为在 app.js 中还会配置router.get(&quot;/&quot;, (req, res, next) =&gt; &#123; var query = &quot;select * from xxx&quot;; db.query(query, (err, rows, fileds) =&gt; &#123; if (err) throw err; res.send(rows); &#125;);&#125;); 在根目录的 app.js 中 1234// 引入路由文件var indexRouter = require(&quot;./routes/index&quot;);// 处理路由app.use(&quot;/index&quot;, indexRouter); 这里配置处理路由之后，客户端要请求 index，直接请求 /index 就行。这样进行细分就更方便请求。。。 所以现在在 index.js 的基础上可以加上其他的请求地址，例如实现插入 12345678910router.post(&quot;/add&quot;, (req, res, next) =&gt; &#123; var params = [req.body.id, req.body.name]; var query = &quot;insert into student(id,name) values (?,?)&quot;; db.query(query, params, (err, rows, fileds) =&gt;&#123; if (err) console.log(err); return; res.send(&quot;成功！&quot;) &#125;); &#125;);","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"express","slug":"express","permalink":"https://gitee.com/dsjerry/smalljerry/tags/express/"},{"name":"node.js","slug":"node-js","permalink":"https://gitee.com/dsjerry/smalljerry/tags/node-js/"}]},{"title":"微信小程序 - 一些基础","slug":"微信小程序","date":"2020-05-18T11:43:47.000Z","updated":"2020-07-21T09:03:33.926Z","comments":true,"path":"2020/05/18/微信小程序/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/05/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"为了方便查找和复习，粗略列出一些可能常用到的 标签、标签的属性、标签属性的值、方法、API。具体的还要以官方文档为主 一些标签 下面表示默认值时在 () 里面，表示Boolean值时使用 √和 × view 视图容器 text 文本域 button 按钮 type：按钮类型 primary（绿色） default（白色） warn（红色） size：按钮大小，（ default 和 mini ）","text":"为了方便查找和复习，粗略列出一些可能常用到的 标签、标签的属性、标签属性的值、方法、API。具体的还要以官方文档为主 一些标签 下面表示默认值时在 () 里面，表示Boolean值时使用 √和 × view 视图容器 text 文本域 button 按钮 type：按钮类型 primary（绿色） default（白色） warn（红色） size：按钮大小，（ default 和 mini ） image 图片 mode：图片裁剪、缩放的模式（scaleToFill） 默认宽度：300px，高度：240px form 表单 bindsubmit：携带 form 中的数据提交 checkbox 复选框 radio 单选框 input 输入框…这里是单标签，并且标签内部要加入 / 作为结尾 type 的合法值 text：文本输入键盘（默认） number：数字输入键盘 idcard：身份证输入键盘 digit：带小数点的数字键盘 password：是否是密码类型（×） placeholder-style：指定这个东西的样式（placeholder-class，指定样式类） bindblur：失去焦点时触发 progress 进度条 swiper 轮播图，子标签swiper-item indicator-dots：是否显示面板知识点 （×） indicator-color：指示点颜色 （rgba(0,0,0,.3)） indicator-active-color：知识点选中颜色 （#000000） autoplay：自动播放 （×） current：当前滑块所处的 index（0） current-item-id：当前滑块所在的 item-id，不能同时指向current（String类型） 配合 &lt;swiper-item&gt; 使用，&lt;swiper current-item-id=&quot;b&quot;&gt; &lt;swiper-item item-id=&quot;b&quot;&gt; interval：自动切换时间间隔(ms)，（5000） duration：滑块动画时长(ms)，（500） circular：是否采用衔接滑动（×） vertical：滑动的方向是否为纵向（×） bindchange：current 改变时触发的 change 事件 include 代码引用 src：引用的 wxml位置 slider 表单组件，滑动选取某一个值 backgroundColor：背景条颜色（ activeColor：已选择的颜色） max、min：最大最小值 step：步长，取值大于0且可被max‘min整除 video视频播放 src：你懂得 ^ ^V^ loop：是否自动播放（×） controls：是否默认显示播放控件（√） enab-danmu：是否展示弹幕（×） danmu-list：弹幕列表 danmu-btn：是否显示弹幕 autoplay：自动播放（×） poster：视频封面的网络地址，controls 为（×）的时候设置无效 bindplay / bindpause：触发事件 map 地图相关 latitude：维度、longitude：经度（Number） scale：缩放级别，范围是 5~18（16）（Number） marker：标记点、poline：路线、circles：圆（Array） show-location：显示带有当先的当前定位点 bindmarktap：单击标记点时触发，返回 maker 或 id （EventHandle，以下也是） bindregionchange：视野发生改变的时侯 bindtap：单击地图、bindupdate：地图渲染更新完成 picker 从底部弹起滚动选择器 header-text：选择器标题（仅安卓可用） mode：选择器类型 selector、multiSelector、time、date、region（省份） bindcancel：取消选择时触发（eventHandle） disable：禁用（false） picker-view 嵌入的滚动选择器 scroll-view 实现可滚动视图区域 scroll-x / scroll-y 允许横向/纵向滚动（×） 纵向滚动需要在样式中为scroll-view设置一个固定高度，否则它会被子元素撑大 scroll-top/scroll-left 设置竖向/横向滚动条的位置（number / string） bindscroll 滚动时触发的事件 一些API 音频 API 创建一个 InnerAudioContext 实例 var audioCtx = wx.createInnerAudioContext() ，audioCtx 是一个实例，也就是一个对象，里面有许多属性和方法 属性： src(嘿嘿嘿)、starttime(开始时间)、autoplay(自动播放)、volume(音量) duration(音频长度，当前合法src的长度)、currentTime(当前时间)、paused(当前是暂停或是停止状态) 方法： play()、pause()、stop()、seek()、destroy()：销毁当前实例 以下触发的时候，参数都是 callback onCanplay(音频进入可播放状态时的事件) onPlay()、onPause()、onStop、onSeek()、onError()、onEnd()：自然播放到结束、onTimeUpdate()：播放进度更新 背景音乐API 创建一个 BackgroundAudioManager 实例对象 var bgm = getBackgroundAudioManager() 在 app.json 中添加配置：&quot;requireBackgroundModes&quot;: [&quot;audio&quot;] 打电话 wx.makePhoneCall( &#123; phoneNumber: &#39;1311111111&#39; &#125; ) 获取位置 wx.getLocation() 方法获取用户当前的位置 wx.openLocation() 方法显示该位置的地图 视频API (VideoContext) wx.createVideoContext() 的一些常用方法 play()/pause()/stop()，播放/暂停/停止 seek(number)：跳转到指定位置 playbackRate(number)：播放倍速 requestFullScreen() / exitFullScreen()：全屏/退出全屏 sendDanmu：发送弹幕 一些事件监听 bindtap 表示绑定 tap 事件，点击触发 通过实践对象 e 可以获取 type ：事件类型 timestamp ：事件生成时的时间戳 target ：触发事件的组件的一些属性值集合 currentTarget ：当前组件的一些属性值集合 detail ：额外的信息 catch 事件是可以阻止事件冒泡的，bind 事件不行 this.setDate( { } ) ,该方法的参数是一个对象 bindchange 当value值改变的时候触发 一些配置 “plugins” 中添加第三方插件 “window” 中配置页面的整体标题栏样式 “tabBar” 配置底部的菜单 最多可以配置5个选项 “requiredBackgroundModes”: [“audio”] 请求背景音乐 “usingComponents” 用在页面的配置文件中，表示使用组件 一些单位 vw 和 vh，分别表示页面的百分之百宽和百分之百高 rpx，常用的单位，750rpx 正好是页面宽度的大小 一些插件 腾讯视频插件 小程序管理后台，设置 - 第三方服务 - 添加插件 在全局 app.json 中： 123456&quot;plugins&quot;: &#123; &quot;tencentvideo&quot;: &#123; &quot;version&quot;: &quot;当前版本&quot;, &quot;provider&quot;: &quot;插件里面的AppID&quot; &#125;&#125; 在使用插件的具体文件中，如：video.json 123&quot;usingComponents&quot;: &#123; &quot;txv-video&quot;: &quot;plugin://tencentvideo/video&quot;&#125; txv-video 名字随便起，将用到 wxml 页面,和 js 中 在 xxx.wxml 中： 1&lt;txv-video vid=&quot;xxxmmm&quot; playerid=&quot;txv1&quot;&gt;&lt;/txv-video&gt; vid ：在腾讯视频指定视频的 url 后面，如果不行，点分享，在分享链接中也可以找到 playerid：指定当前标签，是一个特殊标记，可以随便起一个有特色的的 在相对应的 xxx.js 中：首先要使用 requirePlugin() 引入插件，然后调用 getTxvContext() 123456onReady: function()&#123; const TxvContext = requirePlugin(&#x27;tencentVideo&#x27;) var txvContext = TxvContext.getTxvContext(&#x27;txv1&#x27;) txv.Context.play() txv.Context.pause()&#125; 一些细节 通过dataset区分元素（input） 可以使用 data-id 取代掉 id，例如：data-id=“num”，在绑定的事件中通过 e.target.dataset.id就可以获得 而且，通过e.target.dataset.名称就可以获得 data-名称 的值 一些注意 first-child 和 last-child 相对的是使用元素的本身 &lt;div&gt; &lt;view&gt;我是①&lt;/view&gt; &lt;view&gt;我是②&lt;/view&gt; &lt;/div&gt; 如果要选中div里面的 view ，写的应该是 div view:first-child 使用 import 调用外部样式：import “ 路径 “ WXS 大名 WeiXin Script，和 js 差不多，是小程序的脚本语言，可以在 wxml 中插入 123456&lt;wxs module=&quot;haha&quot;&gt; module.exports = function(value)&#123; var x =xxx var m = mmm &#125;&lt;/wxs&gt; 属性 module 表示模块名称，导出后，可以在标签中使用 1&lt;view&gt; &#123;&#123; haha(xm) &#125;&#125; &lt;/view&gt;","categories":[{"name":"课堂学习","slug":"课堂学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"webpack D1","slug":"webpack-D1","date":"2020-04-18T14:10:03.000Z","updated":"2020-07-21T09:00:33.336Z","comments":true,"path":"2020/04/18/webpack-D1/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/04/18/webpack-D1/","excerpt":"小记：现在 web 开发有着一些不方便的时候。比如文件依赖关系错综复杂、静态资源请求效率低、模块化支持不好、浏览器对高级 JavaScript 特性兼容程度低等问题。 使用 webpack1 . 在使用 webpack 之前，先 npm init 生成 package.json 文件2 . 安装 webpack 和 webpack-cli，npm install webpack webpack-cli -D3 . 在根目录创建配置文件 webpack.config.js ，初始话配置文件 123module.exports = &#123; mode: &quot;development&quot;,&#125;;","text":"小记：现在 web 开发有着一些不方便的时候。比如文件依赖关系错综复杂、静态资源请求效率低、模块化支持不好、浏览器对高级 JavaScript 特性兼容程度低等问题。 使用 webpack1 . 在使用 webpack 之前，先 npm init 生成 package.json 文件2 . 安装 webpack 和 webpack-cli，npm install webpack webpack-cli -D3 . 在根目录创建配置文件 webpack.config.js ，初始话配置文件 123module.exports = &#123; mode: &quot;development&quot;,&#125;; 其中 mode 用来指定构建模式 development 模式不会压缩代码，production 模式则会压缩代码，体积小一些 4 . 在 package.json 配置文件中的 script 节点下增加 dev 脚本 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack&quot;&#125; scripts 节点下的脚本，可以使用 $ npm run 来执行。比如这里是 $ npm run dev 下面有更改 这样一个简单的 webpack 打包就完成了，打包默认生成的文件是 main.js 配置 webpack1 . 配置打包的入口和出口（处理打包的文件）。在 webpack.config.js 中 12345678const path = require(&quot;path&quot;);module.exports = &#123; entry: path.join(__dirname, &quot;要打包的文件路径及文件&quot;), output: &#123; path: path.join(__dirname, &quot;./dist&quot;), // 文件输出路径 filename: &quot;bundle.js&quot;, // 输出的文件名（不是固定名称） &#125;,&#125;; 2 . webpack 自动打包，修改后保存，自动刷新文件，比如 css。使用 npm install webpack-dev-server -D 安装自动打包工具。 在 webpack.config.js 中 123devServer: &#123; contentBase: &quot;./dist&quot;,&#125; 在 package.json 中 1&quot;start&quot;: &quot;webpack-dev-server --open&quot; 其中 --open 表示打包创建服务器后自动打开浏览器。 --host 配置 IP 地址 --port 配置端口 “webpack-dev-server –open –host 127.0.0.1 –port 8080” 3 . 这样配置后，启动服务器默认打开的是一个路径，要修改器默认打开的页面 npm install html-webpack-plugin -D 安装生成预览页面的插件。 在 webpack.config.js 文件中 12345const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); // 导入模块，得到一个构造函数const htmlPlugin = new HtmlWebpackPlugin(&#123; template: &quot;要制定的模板文件&quot;, filename: &quot;index.html&quot;, // 该文件生成在内存中，在目录不会显示出来&#125;); 在 webpack.config.js 的暴露中添加配置节点 123module.exports = &#123; plugins: [htmlPlugin],&#125;; plugins 数组是 webpack 打包期间会用到的一些插件列表 webpack 中的加载器通过 loader 打包非 js 模块 webpack 默认只能处理 .js 结尾的模块，所以要想打包其他类型的文件，需要调用 loader 加载器 webpack 打包处理过程： 1. 打包 css 文件 npm install style-loader css-loader -D 安装 css 文件 loader 在 webpack.config.js 中的 module 中 配置 _rules_，添加匹配规则 12345module: &#123; rules: [ &#123;test: /\\.css$/, use: &#123;&quot;style-loader&quot;, &quot;css-loader&quot;&#125;&#125; ]&#125; 其中 test 标识文件类型，use 标识要使用的 loaderloader 是有顺序的，从右往左，是依赖关系 2. 打包 less 文件 npm install less-loader -D 匹配规则 12345module: &#123; rules: [ &#123;test: /\\.less$/, use: &#123;&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;&#125;&#125; ]&#125; 注意，使用 less 之前要先安装 less。npm install less &gt; less-loader 要依赖于 css-loader less 的格式： 123456body &#123; background-color: darkcyan; ul &#123; font-size: 23px; &#125;&#125; 3. 打包处理 scss 文件 npm install sass-loader node-sass -D ，安装的时候是 sass_，但后缀名是 _scss 12345module: &#123; rules: [ &#123;test: /\\.scss$/, use: &#123;&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;scss-loader&quot;&#125;&#125; ]&#125; 4. 配置 postCSS 自动添加 css 的浏览器兼容前缀 npm i postcss-loader autoprefixer -D 根目录创建 postcss.config.js 文件，配置： 1234const autoprefixer = require(&quot;autoprefixer&quot;);module.exports = &#123; plugins: [autoprefixer], // 挂载插件&#125;; 在 webpack.config.js 中添加匹配规则，依赖于 css： 12345module: &#123; rules: [ &#123;test: /\\.scss$/, use: &#123;&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;&#125;&#125; ]&#125; 5. 打包图片和字体 npm i url-loader file-loader -D 在 webpack.config.js 中添加匹配规则: 12345module: &#123; rules: [ &#123; test: /\\.jpg|png|gif|bmp|ttf|svg$/, use: &quot;url-loader?limit=10000&quot; &#125;, ];&#125; 这里不需要其他的 loader 支持，所以不用引入。一个值时可以吧数组去掉? 之后是 loader 的参数， limit 指定图片的大小，单位是字节，当张片小于 limit 的时候，图片会被转化 wei base64，（图片 url 改变了） 6. 打包处理 js 中的高级语法 安装 babel 转换器相关的包：npm i babel-loader @babel/core @babel/runtime -D 安装 babel 语法插件相关的包：npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D 在根目录创建 babel 配置文件 babel.config.js，配置： 1234567module.exports = &#123; presets: [&quot;@babel/preset-env&quot;], plugins: [ &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-proposal-class-properties&quot;, ],&#125;; 在 webpack.config.js 中，添加 loader 规则： 1&#123;test: /\\.js$/, use: &quot;babel-loader&quot;, exclude: /node_modules/&#125; exclude 表示在 babel-loader 处理的时候要排除的文件 7. webpack 中使用 Vue $ npm install vue -S 在入口文件 index.js 中，import Vue from “vue” 导入 Vue 创建 vue 实例对象 组件中要有一个根组件，App.vue 使用 render 函数渲染 APP 根组件 123456import Vue from &quot;vue&quot;;import App from &quot;./components/App.vue&quot;;const vm = new Vue(&#123; el: &quot;#app&quot;, render: (h) =&gt; h(App),&#125;); App.vue 和其路径是根据情况而定 webpack 打包 vue，使用 render 函数渲染，在局部中不使用 components，这是因为 webpack 中导入的 vue 不是完整的 vue render 函数： 8. webpack 配置 Vue 单文件组件 loader npm i vue-loader vue-template-compiler -D 在 webpack.config.js 中，添加 loader 规则： 1234567const VueLoaderPlugin = require(&quot;vue-loader/lib/plugin&quot;);module.exports = &#123; module: &#123; rules: [&#123; test: /\\.vue$/, loader: &quot;vue-loader&quot; &#125;], &#125;, plugins: [new VueLoaderPlugin()],&#125;; 9. webpack 打包发布上线之前要通过 webpack 将应用进行整体打包，在 package.json 中: 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack -p&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;&#125; build 用于打包命令start 用于开发调试命令","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://gitee.com/dsjerry/smalljerry/tags/webpack/"},{"name":"前端","slug":"前端","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"组件基础","slug":"自学Vue-组件基础","date":"2020-04-03T01:36:19.000Z","updated":"2020-07-21T08:59:46.868Z","comments":true,"path":"2020/04/03/自学Vue-组件基础/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/04/03/%E8%87%AA%E5%AD%A6Vue-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"组件基础基本使用 组件要有一个根元素把子元素包住 组件可以多次使用，而且组件里面数据都是当前组件独享的moment，不关别的组件的事，即使它们的名字是一样的 在使用模板字符串的时候，可以使用单引号、双引号、反引号（ ``），为了模板字符串格式好看，推荐使用反引号 全局注册组件 全局注册的组件可以用在任意的 Vue 根实例中（ new Vue ( { }) ） 使用 Vue.component( “组件名”, “ { 模板字符串等内容 } “) 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;my-com&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;myCom&quot;, &#123; data()&#123; return &#123; msg: &quot;加油加油。&quot; &#125; &#125; template: &quot;&lt;h1&gt;我是一个模板字符串，学习很快乐！&lt;/h1&gt;&quot; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 在全局注册的时候使用的是 驼峰法 或者加 - ，按时在使用的时候只能是加 - ，局部注册也一样 data 和实例 vue 不一样，这里的 data 是一个方法，返回一个对象，数据在里面","text":"组件基础基本使用 组件要有一个根元素把子元素包住 组件可以多次使用，而且组件里面数据都是当前组件独享的moment，不关别的组件的事，即使它们的名字是一样的 在使用模板字符串的时候，可以使用单引号、双引号、反引号（ ``），为了模板字符串格式好看，推荐使用反引号 全局注册组件 全局注册的组件可以用在任意的 Vue 根实例中（ new Vue ( { }) ） 使用 Vue.component( “组件名”, “ { 模板字符串等内容 } “) 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;my-com&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;myCom&quot;, &#123; data()&#123; return &#123; msg: &quot;加油加油。&quot; &#125; &#125; template: &quot;&lt;h1&gt;我是一个模板字符串，学习很快乐！&lt;/h1&gt;&quot; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 在全局注册的时候使用的是 驼峰法 或者加 - ，按时在使用的时候只能是加 - ，局部注册也一样 data 和实例 vue 不一样，这里的 data 是一个方法，返回一个对象，数据在里面 局部注册组件 只能在当前注册了这个组件的 Vue 中使用 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;my-com&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; tempalte:`&lt;div&gt; &lt;h3&gt;努力&lt;/h3&gt; &lt;h3&gt;奋斗&lt;/h3&gt; &lt;/div&gt;` &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, componentss: &#123; &quot;my-com&quot;: login &#125; &#125;)&lt;/script&gt; 父组件向子组件传值 使用 props 在子组件定义一个 props 可以用字符串数组的形式列出，也可以用对象的形式列出 在需要绑定的组件上加上 props 中写好的值，可以静态绑定，即是没有 v-bind 你给它什么值就是什么值, 动态绑定 v-bind 简写为,它的值是父组件 data 中的值 12&lt;my-h1 title=&quot;msg&quot;&gt;&lt;/my-h1&gt;&lt;my-h1 :title=&quot;msg&quot;&gt;&lt;/my-h1&gt; 123456789101112131415Vue.component(&quot;myH1&quot;, &#123; props: [&quot;title&quot;, &quot;title1&quot;], template: ` &lt;div&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;title1&#125;&#125;&lt;/h1&gt; &lt;/div&gt;`&#125;);var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello prop&quot;,&#125;&#125;); 子组件向父组件传值 子组件使用 $emit 触发事件 $emit 的第一个参数为自定义对象的名称，第二个参数是要传递的数据 父组件使用 v-on 监听子组件的事件 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;div :style=&quot;fontSize: fontSize + &#x27;px&#x27; &quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;my-com @enlage-font=&#x27;handle($event)&#x27;&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;myCom&quot;, &#123; template: ` &lt;button @click=&quot;$emit(&#x27;enlageFont&#x27;, 10)&quot;&gt;你点一下试试&lt;/button&gt;` &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;加油加油“, fontSize: 10 &#125;, methods: &#123; handle: function(val)&#123; this.fontSize += val; &#125; &#125; &#125;)&lt;/script&gt; 和使用 props 传值很像 假如我有定义一个方法，需要修改页面的值，但是页面的值来自父组件。这是就需要使用事件抛出一个值 在子组件中,比如我想删除列表中的一项数据（这个就好比是子组件中的props）,可以是表达式，也可以抛出一个对象（{id: id, type=”del”}） 123del: function(id) &#123; this.$emit(&quot;cart-del&quot;, id);&#125; 然后，父组件中(这个就好比是data中的数据) 123456delCart: function(id)&#123; var index = this.goodList.findIndex(item =&gt; &#123; return item.id == id;&#125;); this.goodList.splice(index, 1);&#125; 最后就像props一样，在标签汇中绑定。（props用v-bind，这里用v-on） 1&lt;cart-list @cartDel=&quot;del-cart($event)&quot;&gt;&lt;/cart-list&gt; 组件插槽 自定义组件，在使用的时候不能在其中插入东西，所以要使用 组件插槽 感觉就相当于一个占位符 当组件开始渲染的时候，slot 会被替换成 芜湖 匿名插槽123456789101112&lt;test&gt;芜湖&lt;/test&gt;&lt;script&gt; Vue.component(&#x27;test&#x27;, &#123; data()&#123; return &#123; name: &quot;张三&quot; &#125; &#125; template: `&lt;div&gt; &lt;strong&gt;起飞~&lt;/strong&gt; &lt;slot&gt;&lt;slot&gt; &lt;/div&gt;` &#125;)&lt;/script&gt; 插槽内不仅可以放文本，还可以放 HTML、其他自定义组件 如果没有 slot 标签，自定义的内容将不会显示 插槽传值以及值得作用域1234&lt;test url=&quot;/aoligei&quot;&gt; &#123;&#123; name &#125;&#125; &#123;&#123; url &#125;&#125;&lt;/test&gt; 插槽和模板中的其他兄弟一样，他们能访问到相同作用域的值 上面的值中， name 是可以取得到值得，但是 url 不行，并且显示 undefined。因为 url 已经不是哥儿们了，url的值是传给 test 组件的 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 后备内容123456&lt;!-- 在body中--&gt;&lt;test&gt;&lt;/test&gt;&lt;!-- 在模板中--&gt;&lt;button&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 如果就这样，显示的是 Submit，如果在 test 里面加上 save ，那 submit 就变成 save 具名插槽 当使用了好多个插槽的时候，可以给插槽起个名字 123456789101112&lt;!-- 在模板中 --&gt;&lt;div&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;session&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/session&gt; &lt;footer&gt; &lt;slot name=&quot;fotter&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 不没 name 的 slot 被人取了个花名叫 “default” 使用的时候，要在标签中加一个 template 元素，并且在里面使用 v-slot 绑定，简写 # 12345678910&lt;!-- 在body中(继续用上面的test组件做例子) --&gt;&lt;tset&gt; &lt;template v-slot:header&gt; &lt;h1&gt;加油啊&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;好好学习天天向上&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;每天都是好心情&lt;/p&gt; &lt;/template&gt;&lt;/tset&gt; 这样 slot 就为它命中注定的那个 template 占了位置 作用域插槽 父组件对子组件加工处理 即可复用子组件的 slot，也可以使得 slot 的内容不一样 1234&lt;!-- 在模板中 ○ --&gt;&lt;span&gt; &lt;slot&gt; &#123;&#123;user.lastName&#125;&#125; &lt;/slot&gt;&lt;/span&gt; 然后，我不想使用 lastName 了，我想换个东西 12&lt;!-- 在body中 ※ --&gt;&lt;test&gt; &#123;&#123;user.firstName&#125;&#125; &lt;/test&gt; 这样是不行的，因为在 test 中，他们已经不是 slot 的好兄弟了 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 元素的一个 attribute 绑定上去： 1234&lt;!-- 在模板中 ○ --&gt;&lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &#123;&#123;user.lastName&#125;&#125; &lt;/slot&gt;&lt;/span&gt; 这个绑定在 slot 上的属性叫作 插槽prop 然后就可以使用带值的 v-slot 来定义 插槽prop 的名字了： 123456&lt;!-- 在body中 ※ --&gt;&lt;test&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.first &#125;&#125; &lt;/template&gt;&lt;/test&gt; slotProps 名字随便取 因为 slot 没有名字，所以 这里使用了 default 作为 slot 的属性 如果是没名字，可以直接使用不带参数，也就是直接 v-slot=&quot;slotProps&quot; 一些笔记 $event 通过在方法后面加个 $event 可以访问原生事件对象。比如： 1&lt;input @blur=&quot;warn(&#x27;hahaha&#x27;, $event)&quot;&gt; 在js中定义方法warn 12345warn: function(msg, event)&#123; console.log(msg); console.log(event.target.value); // 获取到input的值&#125; 在字符串模板中，包含模板的是 ` 斜点，而不是单引号或者双引号 findIndex和some是遍历数组的。 语法：array.findIndex(function (currentValue, index, arr), thisValue) currentValue 是必选参数 123var index = this.goodList.findIndex(item =&gt; &#123; return item.id == id;&#125;","categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitee.com/dsjerry/smalljerry/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vue/"}]},{"title":"MYFirstBlog","slug":"MYFirstBlog","date":"2020-03-06T05:11:40.000Z","updated":"2020-03-06T05:16:07.980Z","comments":true,"path":"2020/03/06/MYFirstBlog/","link":"","permalink":"https://gitee.com/dsjerry/smalljerry/2020/03/06/MYFirstBlog/","excerpt":"","text":"FirstHello World！ SecondHello Word!","categories":[],"tags":[]}],"categories":[{"name":"自己学习","slug":"自己学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0/"},{"name":"课堂学习","slug":"课堂学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"},{"name":"技巧学习","slug":"技巧学习","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://gitee.com/dsjerry/smalljerry/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E6%B5%8B%E8%AF%95/"},{"name":"vue","slug":"vue","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vue/"},{"name":"php","slug":"php","permalink":"https://gitee.com/dsjerry/smalljerry/tags/php/"},{"name":"apache","slug":"apache","permalink":"https://gitee.com/dsjerry/smalljerry/tags/apache/"},{"name":"vscode,插件","slug":"vscode-插件","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vscode-%E6%8F%92%E4%BB%B6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E9%9A%8F%E7%AC%94/"},{"name":"后端","slug":"后端","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E5%90%8E%E7%AB%AF/"},{"name":"vuex","slug":"vuex","permalink":"https://gitee.com/dsjerry/smalljerry/tags/vuex/"},{"name":"js","slug":"js","permalink":"https://gitee.com/dsjerry/smalljerry/tags/js/"},{"name":"python","slug":"python","permalink":"https://gitee.com/dsjerry/smalljerry/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E7%88%AC%E8%99%AB/"},{"name":"PHP","slug":"PHP","permalink":"https://gitee.com/dsjerry/smalljerry/tags/PHP/"},{"name":"express","slug":"express","permalink":"https://gitee.com/dsjerry/smalljerry/tags/express/"},{"name":"node.js","slug":"node-js","permalink":"https://gitee.com/dsjerry/smalljerry/tags/node-js/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"webpack","slug":"webpack","permalink":"https://gitee.com/dsjerry/smalljerry/tags/webpack/"},{"name":"前端","slug":"前端","permalink":"https://gitee.com/dsjerry/smalljerry/tags/%E5%89%8D%E7%AB%AF/"}]}